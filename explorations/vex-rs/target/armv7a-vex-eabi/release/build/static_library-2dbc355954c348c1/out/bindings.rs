/* automatically generated by rust-bindgen 0.65.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const V5_SIG_MAGIC: u32 = 894981720;
pub const V5_SIG_TYPE_USER: u32 = 0;
pub const V5_SIG_OWNER_SYS: u32 = 0;
pub const V5_SIG_OWNER_VEX: u32 = 1;
pub const V5_SIG_OWNER_PARTNER: u32 = 2;
pub const V5_SIG_OPTIONS_NONE: u32 = 0;
pub const V5_SIG_OPTIONS_INDG: u32 = 1;
pub const V5_SIG_OPTIONS_EXIT: u32 = 2;
pub const V5_SIG_OPTIONS_THDG: u32 = 4;
pub const V5_MAX_DEVICE_PORTS: u32 = 32;
pub const V5_ADI_PORT_NUM: u32 = 8;
pub const V5_MOTOR_COUNTS_PER_ROT: f64 = 1800.0;
pub const VISION_SIG_FLAG_STATUS: u32 = 1;
pub const FS_SEEK_SET: u32 = 0;
pub const FS_SEEK_CUR: u32 = 1;
pub const FS_SEEK_END: u32 = 2;
pub const FS_FILE_EXIST: u32 = 1;
pub const FS_FILE_DIR: u32 = 2;
pub const V5_COMP_BIT_EBL: u32 = 1;
pub const V5_COMP_BIT_MODE: u32 = 2;
pub const V5_COMP_BIT_COMP: u32 = 4;
pub const V5_COMP_BIT_GAME: u32 = 8;
pub const SYSTEM_DISPLAY_WIDTH: u32 = 480;
pub const SYSTEM_DISPLAY_HEIGHT: u32 = 272;
pub const ClrAliceBlue: u32 = 15792383;
pub const ClrAntiqueWhite: u32 = 16444375;
pub const ClrAqua: u32 = 65535;
pub const ClrAquamarine: u32 = 8388564;
pub const ClrAzure: u32 = 15794175;
pub const ClrBeige: u32 = 16119260;
pub const ClrBisque: u32 = 16770244;
pub const ClrBlack: u32 = 0;
pub const ClrBlanchedAlmond: u32 = 16772045;
pub const ClrBlue: u32 = 255;
pub const ClrBlueViolet: u32 = 9055202;
pub const ClrBrown: u32 = 10824234;
pub const ClrBurlyWood: u32 = 14596231;
pub const ClrCadetBlue: u32 = 6266528;
pub const ClrChartreuse: u32 = 8388352;
pub const ClrChocolate: u32 = 13789470;
pub const ClrCoral: u32 = 16744272;
pub const ClrCornflowerBlue: u32 = 6591981;
pub const ClrCornsilk: u32 = 16775388;
pub const ClrCrimson: u32 = 14423100;
pub const ClrCyan: u32 = 65535;
pub const ClrDarkBlue: u32 = 139;
pub const ClrDarkCyan: u32 = 35723;
pub const ClrDarkGoldenrod: u32 = 12092939;
pub const ClrDarkGray: u32 = 11119017;
pub const ClrDarkGreen: u32 = 25600;
pub const ClrDarkKhaki: u32 = 12433259;
pub const ClrDarkMagenta: u32 = 9109643;
pub const ClrDarkOliveGreen: u32 = 5597999;
pub const ClrDarkOrange: u32 = 16747520;
pub const ClrDarkOrchid: u32 = 10040012;
pub const ClrDarkRed: u32 = 9109504;
pub const ClrDarkSalmon: u32 = 15308410;
pub const ClrDarkSeaGreen: u32 = 9419919;
pub const ClrDarkSlateBlue: u32 = 4734347;
pub const ClrDarkSlateGray: u32 = 3100495;
pub const ClrDarkTurquoise: u32 = 52945;
pub const ClrDarkViolet: u32 = 9699539;
pub const ClrDeepPink: u32 = 16716947;
pub const ClrDeepSkyBlue: u32 = 49151;
pub const ClrDimGray: u32 = 6908265;
pub const ClrDodgerBlue: u32 = 2003199;
pub const ClrFireBrick: u32 = 11674146;
pub const ClrFloralWhite: u32 = 16775920;
pub const ClrForestGreen: u32 = 2263842;
pub const ClrFuchsia: u32 = 16711935;
pub const ClrGainsboro: u32 = 14474460;
pub const ClrGhostWhite: u32 = 16316671;
pub const ClrGold: u32 = 16766720;
pub const ClrGoldenrod: u32 = 14329120;
pub const ClrGray: u32 = 8421504;
pub const ClrGreen: u32 = 32768;
pub const ClrGreenYellow: u32 = 11403055;
pub const ClrHoneydew: u32 = 15794160;
pub const ClrHotPink: u32 = 16738740;
pub const ClrIndianRed: u32 = 13458524;
pub const ClrIndigo: u32 = 4915330;
pub const ClrIvory: u32 = 16777200;
pub const ClrKhaki: u32 = 15787660;
pub const ClrLavender: u32 = 15132410;
pub const ClrLavenderBlush: u32 = 16773365;
pub const ClrLawnGreen: u32 = 8190976;
pub const ClrLemonChiffon: u32 = 16775885;
pub const ClrLightBlue: u32 = 11393254;
pub const ClrLightCoral: u32 = 15761536;
pub const ClrLightCyan: u32 = 14745599;
pub const ClrLightGoldenrodYellow: u32 = 16448210;
pub const ClrLightGreen: u32 = 9498256;
pub const ClrLightGrey: u32 = 13882323;
pub const ClrLightPink: u32 = 16758465;
pub const ClrLightSalmon: u32 = 16752762;
pub const ClrLightSeaGreen: u32 = 2142890;
pub const ClrLightSkyBlue: u32 = 8900346;
pub const ClrLightSlateGray: u32 = 7833753;
pub const ClrLightSteelBlue: u32 = 11584734;
pub const ClrLightYellow: u32 = 16777184;
pub const ClrLime: u32 = 65280;
pub const ClrLimeGreen: u32 = 3329330;
pub const ClrLinen: u32 = 16445670;
pub const ClrMagenta: u32 = 16711935;
pub const ClrMaroon: u32 = 8388608;
pub const ClrMediumAquamarine: u32 = 6737322;
pub const ClrMediumBlue: u32 = 205;
pub const ClrMediumOrchid: u32 = 12211667;
pub const ClrMediumPurple: u32 = 9662683;
pub const ClrMediumSeaGreen: u32 = 3978097;
pub const ClrMediumSlateBlue: u32 = 8087790;
pub const ClrMediumSpringGreen: u32 = 64154;
pub const ClrMediumTurquoise: u32 = 4772300;
pub const ClrMediumVioletRed: u32 = 13047173;
pub const ClrMidnightBlue: u32 = 1644912;
pub const ClrMintCream: u32 = 16121850;
pub const ClrMistyRose: u32 = 16770273;
pub const ClrMoccasin: u32 = 16770229;
pub const ClrNavajoWhite: u32 = 16768685;
pub const ClrNavy: u32 = 128;
pub const ClrOldLace: u32 = 16643558;
pub const ClrOlive: u32 = 8421376;
pub const ClrOliveDrab: u32 = 7048739;
pub const ClrOrange: u32 = 16753920;
pub const ClrOrangeRed: u32 = 16729344;
pub const ClrOrchid: u32 = 14315734;
pub const ClrPaleGoldenrod: u32 = 15657130;
pub const ClrPaleGreen: u32 = 10025880;
pub const ClrPaleTurquoise: u32 = 11529966;
pub const ClrPaleVioletRed: u32 = 14381203;
pub const ClrPapayaWhip: u32 = 16773077;
pub const ClrPeachPuff: u32 = 16767673;
pub const ClrPeru: u32 = 13468991;
pub const ClrPink: u32 = 16761035;
pub const ClrPlum: u32 = 14524637;
pub const ClrPowderBlue: u32 = 11591910;
pub const ClrPurple: u32 = 8388736;
pub const ClrRed: u32 = 16711680;
pub const ClrRosyBrown: u32 = 12357519;
pub const ClrRoyalBlue: u32 = 4286945;
pub const ClrSaddleBrown: u32 = 9127187;
pub const ClrSalmon: u32 = 16416882;
pub const ClrSandyBrown: u32 = 16032864;
pub const ClrSeaGreen: u32 = 3050327;
pub const ClrSeashell: u32 = 16774638;
pub const ClrSienna: u32 = 10506797;
pub const ClrSilver: u32 = 12632256;
pub const ClrSkyBlue: u32 = 8900331;
pub const ClrSlateBlue: u32 = 6970061;
pub const ClrSlateGray: u32 = 7372944;
pub const ClrSnow: u32 = 16775930;
pub const ClrSpringGreen: u32 = 65407;
pub const ClrSteelBlue: u32 = 4620980;
pub const ClrTan: u32 = 13808780;
pub const ClrTeal: u32 = 32896;
pub const ClrThistle: u32 = 14204888;
pub const ClrTomato: u32 = 16737095;
pub const ClrTurquoise: u32 = 4251856;
pub const ClrViolet: u32 = 15631086;
pub const ClrWheat: u32 = 16113331;
pub const ClrWhite: u32 = 16777215;
pub const ClrWhiteSmoke: u32 = 16119285;
pub const ClrYellow: u32 = 16776960;
pub const ClrYellowGreen: u32 = 10145074;
pub const ClrRedMask: u32 = 16711680;
pub const ClrRedShift: u32 = 16;
pub const ClrGreenMask: u32 = 65280;
pub const ClrGreenShift: u32 = 8;
pub const ClrBlueMask: u32 = 255;
pub const ClrBlueShift: u32 = 0;
pub const FONT_MONO_CELL_WIDTH: u32 = 10;
pub const FONT_MONO_CELL_HEIGHT: u32 = 20;
pub const FONT_MONO_CELL_BASE: u32 = 4;
pub const FONT_PROP_CELL_WIDTH: u32 = 10;
pub const FONT_PROP_CELL_HEIGHT: u32 = 20;
pub const FONT_PROP_CELL_BASE: u32 = 4;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = ::core::ffi::c_longlong;
pub type uintmax_t = ::core::ffi::c_ulonglong;
pub type __gnuc_va_list = u32;
pub type va_list = u32;
#[doc = " @details\n   The first 16 bytes of a user code binary should contain the user code\n   signature.  For simple user code programs this will be created by the\n   startup code in the runtime library, certain types of user code,\n   for example a virtual machine, may override the default settings to cause\n   the V5 system code to enable custom functionality yet TBD.\n\n   to override the default use a definition like this in one of the user\n   code source files.\n\n   __attribute__ ((section (\".boot_data\"))) vcodesig vexCodeSig =\n   { V5_SIG_MAGIC,\n     V5_SIG_TYPE_USER,\n     V5_SIG_OWNER_VEX,\n     V5_SIG_OPTIONS_NONE\n   };\n\n   V5_SIG_MAGIC must be set, other fields and their behavior are TBD\n\n   vexCodeSig is defined as \"weak\" and this definition will override it."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _vcodesig {
    pub magic: u32,
    pub type_: u32,
    pub owner: u32,
    pub options: u32,
}
#[doc = " @details\n   The first 16 bytes of a user code binary should contain the user code\n   signature.  For simple user code programs this will be created by the\n   startup code in the runtime library, certain types of user code,\n   for example a virtual machine, may override the default settings to cause\n   the V5 system code to enable custom functionality yet TBD.\n\n   to override the default use a definition like this in one of the user\n   code source files.\n\n   __attribute__ ((section (\".boot_data\"))) vcodesig vexCodeSig =\n   { V5_SIG_MAGIC,\n     V5_SIG_TYPE_USER,\n     V5_SIG_OWNER_VEX,\n     V5_SIG_OPTIONS_NONE\n   };\n\n   V5_SIG_MAGIC must be set, other fields and their behavior are TBD\n\n   vexCodeSig is defined as \"weak\" and this definition will override it."]
pub type vcodesig = _vcodesig;
#[doc = " @brief      Structures used by system time functions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct time {
    pub ti_hour: u8,
    #[doc = " Hours"]
    pub ti_min: u8,
    #[doc = " Minutes"]
    pub ti_sec: u8,
    #[doc = " Seconds"]
    pub ti_hund: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct date {
    pub da_year: u16,
    #[doc = " Year - 1980"]
    pub da_day: u8,
    #[doc = " Day of the month"]
    pub da_mon: u8,
}
pub const V5_DeviceType_kDeviceTypeNoSensor: V5_DeviceType = 0;
pub const V5_DeviceType_kDeviceTypeMotorSensor: V5_DeviceType = 2;
pub const V5_DeviceType_kDeviceTypeLedSensor: V5_DeviceType = 3;
pub const V5_DeviceType_kDeviceTypeAbsEncSensor: V5_DeviceType = 4;
pub const V5_DeviceType_kDeviceTypeCrMotorSensor: V5_DeviceType = 5;
pub const V5_DeviceType_kDeviceTypeImuSensor: V5_DeviceType = 6;
pub const V5_DeviceType_kDeviceTypeRangeSensor: V5_DeviceType = 7;
pub const V5_DeviceType_kDeviceTypeDistanceSensor: V5_DeviceType = 7;
pub const V5_DeviceType_kDeviceTypeRadioSensor: V5_DeviceType = 8;
pub const V5_DeviceType_kDeviceTypeTetherSensor: V5_DeviceType = 9;
pub const V5_DeviceType_kDeviceTypeBrainSensor: V5_DeviceType = 10;
pub const V5_DeviceType_kDeviceTypeVisionSensor: V5_DeviceType = 11;
pub const V5_DeviceType_kDeviceTypeAdiSensor: V5_DeviceType = 12;
pub const V5_DeviceType_kDeviceTypeRes1Sensor: V5_DeviceType = 13;
pub const V5_DeviceType_kDeviceTypeRes2Sensor: V5_DeviceType = 14;
pub const V5_DeviceType_kDeviceTypeRes3Sensor: V5_DeviceType = 15;
pub const V5_DeviceType_kDeviceTypeOpticalSensor: V5_DeviceType = 16;
pub const V5_DeviceType_kDeviceTypeMagnetSensor: V5_DeviceType = 17;
pub const V5_DeviceType_kDeviceTypeGpsSensor: V5_DeviceType = 20;
pub const V5_DeviceType_kDeviceTypeBumperSensor: V5_DeviceType = 64;
pub const V5_DeviceType_kDeviceTypeGyroSensor: V5_DeviceType = 70;
pub const V5_DeviceType_kDeviceTypeSonarSensor: V5_DeviceType = 71;
pub const V5_DeviceType_kDeviceTypeGenericSensor: V5_DeviceType = 128;
pub const V5_DeviceType_kDeviceTypeGenericSerial: V5_DeviceType = 129;
pub const V5_DeviceType_kDeviceTypeUndefinedSensor: V5_DeviceType = 255;
#[doc = " @brief      V5 Device type definitions"]
pub type V5_DeviceType = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_Device {
    _unused: [u8; 0],
}
pub type V5_DeviceT = *mut _V5_Device;
pub type V5_DeviceTypeBuffer = [V5_DeviceType; 32usize];
pub const _V5_ControllerIndex_AnaLeftX: _V5_ControllerIndex = 0;
pub const _V5_ControllerIndex_AnaLeftY: _V5_ControllerIndex = 1;
pub const _V5_ControllerIndex_AnaRightX: _V5_ControllerIndex = 2;
pub const _V5_ControllerIndex_AnaRightY: _V5_ControllerIndex = 3;
pub const _V5_ControllerIndex_AnaSpare1: _V5_ControllerIndex = 4;
pub const _V5_ControllerIndex_AnaSpare2: _V5_ControllerIndex = 5;
pub const _V5_ControllerIndex_Button5U: _V5_ControllerIndex = 6;
pub const _V5_ControllerIndex_Button5D: _V5_ControllerIndex = 7;
pub const _V5_ControllerIndex_Button6U: _V5_ControllerIndex = 8;
pub const _V5_ControllerIndex_Button6D: _V5_ControllerIndex = 9;
pub const _V5_ControllerIndex_Button7U: _V5_ControllerIndex = 10;
pub const _V5_ControllerIndex_Button7D: _V5_ControllerIndex = 11;
pub const _V5_ControllerIndex_Button7L: _V5_ControllerIndex = 12;
pub const _V5_ControllerIndex_Button7R: _V5_ControllerIndex = 13;
pub const _V5_ControllerIndex_Button8U: _V5_ControllerIndex = 14;
pub const _V5_ControllerIndex_Button8D: _V5_ControllerIndex = 15;
pub const _V5_ControllerIndex_Button8L: _V5_ControllerIndex = 16;
pub const _V5_ControllerIndex_Button8R: _V5_ControllerIndex = 17;
pub const _V5_ControllerIndex_ButtonSEL: _V5_ControllerIndex = 18;
pub const _V5_ControllerIndex_BatteryLevel: _V5_ControllerIndex = 19;
pub const _V5_ControllerIndex_ButtonAll: _V5_ControllerIndex = 20;
pub const _V5_ControllerIndex_Flags: _V5_ControllerIndex = 21;
pub const _V5_ControllerIndex_BatteryCapacity: _V5_ControllerIndex = 22;
pub const _V5_ControllerIndex_Axis1: _V5_ControllerIndex = 2;
pub const _V5_ControllerIndex_Axis2: _V5_ControllerIndex = 3;
pub const _V5_ControllerIndex_Axis3: _V5_ControllerIndex = 1;
pub const _V5_ControllerIndex_Axis4: _V5_ControllerIndex = 0;
pub const _V5_ControllerIndex_ButtonL1: _V5_ControllerIndex = 6;
pub const _V5_ControllerIndex_ButtonL2: _V5_ControllerIndex = 7;
pub const _V5_ControllerIndex_ButtonR1: _V5_ControllerIndex = 8;
pub const _V5_ControllerIndex_ButtonR2: _V5_ControllerIndex = 9;
pub const _V5_ControllerIndex_ButtonUp: _V5_ControllerIndex = 10;
pub const _V5_ControllerIndex_ButtonDown: _V5_ControllerIndex = 11;
pub const _V5_ControllerIndex_ButtonLeft: _V5_ControllerIndex = 12;
pub const _V5_ControllerIndex_ButtonRight: _V5_ControllerIndex = 13;
pub const _V5_ControllerIndex_ButtonX: _V5_ControllerIndex = 14;
pub const _V5_ControllerIndex_ButtonB: _V5_ControllerIndex = 15;
pub const _V5_ControllerIndex_ButtonY: _V5_ControllerIndex = 16;
pub const _V5_ControllerIndex_ButtonA: _V5_ControllerIndex = 17;
#[doc = " @brief      V5 Controller definitions"]
pub type _V5_ControllerIndex = ::core::ffi::c_uint;
#[doc = " @brief      V5 Controller definitions"]
pub use self::_V5_ControllerIndex as V5_ControllerIndex;
pub const _V5_ControllerStatus_kV5ControllerOffline: _V5_ControllerStatus = 0;
pub const _V5_ControllerStatus_kV5ControllerTethered: _V5_ControllerStatus = 1;
pub const _V5_ControllerStatus_kV5ControllerVexnet: _V5_ControllerStatus = 2;
pub type _V5_ControllerStatus = ::core::ffi::c_uint;
pub use self::_V5_ControllerStatus as V5_ControllerStatus;
pub const _V5_ControllerId_kControllerMaster: _V5_ControllerId = 0;
pub const _V5_ControllerId_kControllerPartner: _V5_ControllerId = 1;
pub type _V5_ControllerId = ::core::ffi::c_uint;
pub use self::_V5_ControllerId as V5_ControllerId;
pub const _V5_DeviceLedColor_kLedColorBlack: _V5_DeviceLedColor = 0;
pub const _V5_DeviceLedColor_kLedColorRed: _V5_DeviceLedColor = 16711680;
pub const _V5_DeviceLedColor_kLedColorGreen: _V5_DeviceLedColor = 65280;
pub const _V5_DeviceLedColor_kLedColorBlue: _V5_DeviceLedColor = 255;
pub const _V5_DeviceLedColor_kLedColorYellow: _V5_DeviceLedColor = 16776960;
pub const _V5_DeviceLedColor_kLedColorCyan: _V5_DeviceLedColor = 65535;
pub const _V5_DeviceLedColor_kLedColorMagenta: _V5_DeviceLedColor = 16711935;
pub const _V5_DeviceLedColor_kLedColorWhite: _V5_DeviceLedColor = 16777215;
#[doc = " @brief      V5 LED device definitions"]
pub type _V5_DeviceLedColor = ::core::ffi::c_uint;
#[doc = " @brief      V5 LED device definitions"]
pub use self::_V5_DeviceLedColor as V5_DeviceLedColor;
pub const _V5_AdiPortConfiguration_kAdiPortTypeAnalogIn: _V5_AdiPortConfiguration = 0;
pub const _V5_AdiPortConfiguration_kAdiPortTypeAnalogOut: _V5_AdiPortConfiguration = 1;
pub const _V5_AdiPortConfiguration_kAdiPortTypeDigitalIn: _V5_AdiPortConfiguration = 2;
pub const _V5_AdiPortConfiguration_kAdiPortTypeDigitalOut: _V5_AdiPortConfiguration = 3;
pub const _V5_AdiPortConfiguration_kAdiPortTypeSmartButton: _V5_AdiPortConfiguration = 4;
pub const _V5_AdiPortConfiguration_kAdiPortTypeSmartPot: _V5_AdiPortConfiguration = 5;
pub const _V5_AdiPortConfiguration_kAdiPortTypeLegacyButton: _V5_AdiPortConfiguration = 6;
pub const _V5_AdiPortConfiguration_kAdiPortTypeLegacyPotentiometer: _V5_AdiPortConfiguration = 7;
pub const _V5_AdiPortConfiguration_kAdiPortTypeLegacyLineSensor: _V5_AdiPortConfiguration = 8;
pub const _V5_AdiPortConfiguration_kAdiPortTypeLegacyLightSensor: _V5_AdiPortConfiguration = 9;
pub const _V5_AdiPortConfiguration_kAdiPortTypeLegacyGyro: _V5_AdiPortConfiguration = 10;
pub const _V5_AdiPortConfiguration_kAdiPortTypeLegacyAccelerometer: _V5_AdiPortConfiguration = 11;
pub const _V5_AdiPortConfiguration_kAdiPortTypeLegacyServo: _V5_AdiPortConfiguration = 12;
pub const _V5_AdiPortConfiguration_kAdiPortTypeLegacyPwm: _V5_AdiPortConfiguration = 13;
pub const _V5_AdiPortConfiguration_kAdiPortTypeQuadEncoder: _V5_AdiPortConfiguration = 14;
pub const _V5_AdiPortConfiguration_kAdiPortTypeSonar: _V5_AdiPortConfiguration = 15;
pub const _V5_AdiPortConfiguration_kAdiPortTypeLegacyPwmSlew: _V5_AdiPortConfiguration = 16;
pub const _V5_AdiPortConfiguration_kAdiPortTypeUndefined: _V5_AdiPortConfiguration = 255;
#[doc = " @brief      V5 ADI device definitions"]
pub type _V5_AdiPortConfiguration = ::core::ffi::c_uint;
#[doc = " @brief      V5 ADI device definitions"]
pub use self::_V5_AdiPortConfiguration as V5_AdiPortConfiguration;
pub const _V5_DeviceBumperState_kBumperReleased: _V5_DeviceBumperState = 0;
#[doc = " Switch pressed"]
pub const _V5_DeviceBumperState_kBumperPressed: _V5_DeviceBumperState = 1;
#[doc = " @brief      V5 Bumper switch device definitions"]
pub type _V5_DeviceBumperState = ::core::ffi::c_uint;
#[doc = " @brief      V5 Bumper switch device definitions"]
pub use self::_V5_DeviceBumperState as V5_DeviceBumperState;
pub const V5MotorControlMode_kMotorControlModeOFF: V5MotorControlMode = 0;
#[doc = " Motor is off and in coast mode"]
pub const V5MotorControlMode_kMotorControlModeBRAKE: V5MotorControlMode = 1;
#[doc = " Motor is off and in brake mode"]
pub const V5MotorControlMode_kMotorControlModeHOLD: V5MotorControlMode = 2;
#[doc = " Motor is holding at current position"]
pub const V5MotorControlMode_kMotorControlModeSERVO: V5MotorControlMode = 3;
#[doc = " Motor is in \"Servo\" mode. Move to position and hold at that position"]
pub const V5MotorControlMode_kMotorControlModePROFILE: V5MotorControlMode = 4;
#[doc = " Motor moves to set position and stops."]
pub const V5MotorControlMode_kMotorControlModeVELOCITY: V5MotorControlMode = 5;
#[doc = " Motor is unlimited movement at set 'velocity'"]
pub const V5MotorControlMode_kMotorControlModeUNDEFINED: V5MotorControlMode = 6;
#[doc = " @brief      V5 Motor definitions"]
pub type V5MotorControlMode = ::core::ffi::c_uint;
pub const _V5_MotorBrakeMode_kV5MotorBrakeModeCoast: _V5_MotorBrakeMode = 0;
#[doc = " Motor will coast when stopped"]
pub const _V5_MotorBrakeMode_kV5MotorBrakeModeBrake: _V5_MotorBrakeMode = 1;
#[doc = " Motor will brake when stopped"]
pub const _V5_MotorBrakeMode_kV5MotorBrakeModeHold: _V5_MotorBrakeMode = 2;
pub type _V5_MotorBrakeMode = ::core::ffi::c_uint;
pub use self::_V5_MotorBrakeMode as V5MotorBrakeMode;
pub const V5MotorEncoderUnits_kMotorEncoderDegrees: V5MotorEncoderUnits = 0;
#[doc = " degrees Encoder Count Mode"]
pub const V5MotorEncoderUnits_kMotorEncoderRotations: V5MotorEncoderUnits = 1;
#[doc = " rotations Encoder Count Mode"]
pub const V5MotorEncoderUnits_kMotorEncoderCounts: V5MotorEncoderUnits = 2;
pub type V5MotorEncoderUnits = ::core::ffi::c_uint;
pub const _V5MotorGearset_kMotorGearSet_36: _V5MotorGearset = 0;
#[doc = " 36:1 gear set, torque"]
pub const _V5MotorGearset_kMotorGearSet_18: _V5MotorGearset = 1;
#[doc = " 18:1 gear set, speed"]
pub const _V5MotorGearset_kMotorGearSet_06: _V5MotorGearset = 2;
pub type _V5MotorGearset = ::core::ffi::c_uint;
pub use self::_V5MotorGearset as V5MotorGearset;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceMotorPid {
    pub kf: u8,
    pub kp: u8,
    pub ki: u8,
    pub kd: u8,
    pub filter: u8,
    pub pad1: u8,
    pub limit: u16,
    pub threshold: u8,
    pub loopspeed: u8,
    pub pad2: [u8; 2usize],
}
pub type V5_DeviceMotorPid = _V5_DeviceMotorPid;
pub const V5VisionMode_kVisionModeNormal: V5VisionMode = 0;
pub const V5VisionMode_kVisionModeMixed: V5VisionMode = 1;
pub const V5VisionMode_kVisionModeLineDetect: V5VisionMode = 2;
pub const V5VisionMode_kVisionTypeTest: V5VisionMode = 3;
#[doc = " @brief      V5 Vision sensor definitions"]
pub type V5VisionMode = ::core::ffi::c_uint;
pub const V5VisionBlockType_kVisionTypeNormal: V5VisionBlockType = 0;
pub const V5VisionBlockType_kVisionTypeColorCode: V5VisionBlockType = 1;
pub const V5VisionBlockType_kVisionTypeLineDetect: V5VisionBlockType = 2;
pub type V5VisionBlockType = ::core::ffi::c_uint;
pub const V5VisionWBMode_kVisionWBNormal: V5VisionWBMode = 0;
pub const V5VisionWBMode_kVisionWBStart: V5VisionWBMode = 1;
pub const V5VisionWBMode_kVisionWBManual: V5VisionWBMode = 2;
pub type V5VisionWBMode = ::core::ffi::c_uint;
pub const V5VisionLedMode_kVisionLedModeAuto: V5VisionLedMode = 0;
pub const V5VisionLedMode_kVisionLedModeManual: V5VisionLedMode = 1;
pub type V5VisionLedMode = ::core::ffi::c_uint;
pub const V5VisionWifiMode_kVisionWifiModeOff: V5VisionWifiMode = 0;
pub const V5VisionWifiMode_kVisionWifiModeOn: V5VisionWifiMode = 1;
pub type V5VisionWifiMode = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceVisionSignature {
    pub id: u8,
    pub flags: u8,
    pub pad: [u8; 2usize],
    pub range: f32,
    pub uMin: i32,
    pub uMax: i32,
    pub uMean: i32,
    pub vMin: i32,
    pub vMax: i32,
    pub vMean: i32,
    pub mRgb: u32,
    pub mType: u32,
}
pub type V5_DeviceVisionSignature = _V5_DeviceVisionSignature;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceVisionObject {
    pub signature: u16,
    #[doc = " block signature"]
    pub type_: V5VisionBlockType,
    #[doc = " block type"]
    pub xoffset: u16,
    #[doc = " left side of block"]
    pub yoffset: u16,
    #[doc = " top of block"]
    pub width: u16,
    #[doc = " width of block"]
    pub height: u16,
    #[doc = " height of block"]
    pub angle: u16,
}
pub type V5_DeviceVisionObject = _V5_DeviceVisionObject;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceVisionRgb {
    pub red: u8,
    pub green: u8,
    pub blue: u8,
    pub brightness: u8,
}
pub type V5_DeviceVisionRgb = _V5_DeviceVisionRgb;
#[doc = " @brief      V5 IMU sensor definitions"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceImuQuaternion {
    pub a: f64,
    pub b: f64,
    pub c: f64,
    pub d: f64,
}
#[doc = " @brief      V5 IMU sensor definitions"]
pub type V5_DeviceImuQuaternion = _V5_DeviceImuQuaternion;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceImuAttitude {
    pub pitch: f64,
    pub roll: f64,
    pub yaw: f64,
}
pub type V5_DeviceImuAttitude = _V5_DeviceImuAttitude;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceImuRaw {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
pub type V5_DeviceImuRaw = _V5_DeviceImuRaw;
pub const _V5ImuHeadingnMode_kImuHeadingNative: _V5ImuHeadingnMode = 0;
pub const _V5ImuHeadingnMode_kImuHeadingIQ: _V5ImuHeadingnMode = 1;
pub type _V5ImuHeadingnMode = ::core::ffi::c_uint;
pub const _V5ImuOrientationMode_kImuOrientationZUp: _V5ImuOrientationMode = 0;
pub const _V5ImuOrientationMode_kImuOrientationZDown: _V5ImuOrientationMode = 16;
pub const _V5ImuOrientationMode_kImuOrientationXUp: _V5ImuOrientationMode = 32;
pub const _V5ImuOrientationMode_kImuOrientationXDown: _V5ImuOrientationMode = 48;
pub const _V5ImuOrientationMode_kImuOrientationYUp: _V5ImuOrientationMode = 64;
pub const _V5ImuOrientationMode_kImuOrientationYDown: _V5ImuOrientationMode = 80;
pub const _V5ImuOrientationMode_kImuOrientationAuto: _V5ImuOrientationMode = 128;
pub type _V5ImuOrientationMode = ::core::ffi::c_uint;
pub use self::_V5ImuOrientationMode as V5ImuOrientationMode;
pub const _V5ImuQuaternionMode_kImuQuaternionProcessed: _V5ImuQuaternionMode = 0;
pub const _V5ImuQuaternionMode_kImuQuaternionRaw: _V5ImuQuaternionMode = 256;
pub type _V5ImuQuaternionMode = ::core::ffi::c_uint;
pub use self::_V5ImuQuaternionMode as V5ImuQuaternionMode;
#[doc = " @brief      V5 Color sensor definitions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceOpticalRaw {
    pub clear: u16,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
}
#[doc = " @brief      V5 Color sensor definitions"]
pub type V5_DeviceOpticalRaw = _V5_DeviceOpticalRaw;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceOpticalRgb {
    pub red: f64,
    pub green: f64,
    pub blue: f64,
    pub brightness: f64,
}
pub type V5_DeviceOpticalRgb = _V5_DeviceOpticalRgb;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceOpticalGesture {
    pub udata: u8,
    pub ddata: u8,
    pub ldata: u8,
    pub rdata: u8,
    pub type_: u8,
    pub pad: u8,
    pub count: u16,
    pub time: u32,
}
pub type V5_DeviceOpticalGesture = _V5_DeviceOpticalGesture;
pub const _V5_DeviceMagnetDuration_kMagnetDurationShort: _V5_DeviceMagnetDuration = 0;
pub const _V5_DeviceMagnetDuration_kMagnetDurationMedium: _V5_DeviceMagnetDuration = 1;
pub const _V5_DeviceMagnetDuration_kMagnetDurationLong: _V5_DeviceMagnetDuration = 2;
pub const _V5_DeviceMagnetDuration_kMagnetDurationExtraLong: _V5_DeviceMagnetDuration = 3;
#[doc = " @brief      V5 magnet definitions"]
pub type _V5_DeviceMagnetDuration = ::core::ffi::c_uint;
#[doc = " @brief      V5 magnet definitions"]
pub use self::_V5_DeviceMagnetDuration as V5_DeviceMagnetDuration;
#[doc = " @brief      V5 gps definitions"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceGpsQuaternion {
    pub a: f64,
    pub b: f64,
    pub c: f64,
    pub d: f64,
}
#[doc = " @brief      V5 gps definitions"]
pub type V5_DeviceGpsQuaternion = _V5_DeviceGpsQuaternion;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceGpsAttitude {
    pub pitch: f64,
    pub roll: f64,
    pub yaw: f64,
    pub position_x: f64,
    pub position_y: f64,
    pub position_z: f64,
    pub az: f64,
    pub el: f64,
    pub rot: f64,
}
pub type V5_DeviceGpsAttitude = _V5_DeviceGpsAttitude;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceGpsRaw {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
pub type V5_DeviceGpsRaw = _V5_DeviceGpsRaw;
#[doc = " @brief      V5 AI Camera definitions"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_DeviceAicamObject {
    pub type_: i16,
    pub xpos: i16,
    pub ypos: i16,
    pub zpos: i16,
    pub width: i16,
    pub height: i16,
}
#[doc = " @brief      V5 AI Camera definitions"]
pub type V5_DeviceAicamObject = _V5_DeviceAicamObject;
#[doc = " @brief      V5 SD File system definitions"]
pub type FIL = ::core::ffi::c_void;
pub const FRESULT_FR_OK: FRESULT = 0;
#[doc = " (0) Succeeded"]
pub const FRESULT_FR_DISK_ERR: FRESULT = 1;
#[doc = " (1) A hard error occurred in the low level disk I/O layer"]
pub const FRESULT_FR_INT_ERR: FRESULT = 2;
#[doc = " (2) Assertion failed"]
pub const FRESULT_FR_NOT_READY: FRESULT = 3;
#[doc = " (3) The physical drive cannot work"]
pub const FRESULT_FR_NO_FILE: FRESULT = 4;
#[doc = " (4) Could not find the file"]
pub const FRESULT_FR_NO_PATH: FRESULT = 5;
#[doc = " (5) Could not find the path"]
pub const FRESULT_FR_INVALID_NAME: FRESULT = 6;
#[doc = " (6) The path name format is invalid"]
pub const FRESULT_FR_DENIED: FRESULT = 7;
#[doc = " (7) Access denied due to prohibited access or directory full"]
pub const FRESULT_FR_EXIST: FRESULT = 8;
#[doc = " (8) Access denied due to prohibited access"]
pub const FRESULT_FR_INVALID_OBJECT: FRESULT = 9;
#[doc = " (9) The file/directory object is invalid"]
pub const FRESULT_FR_WRITE_PROTECTED: FRESULT = 10;
#[doc = " (10) The physical drive is write protected"]
pub const FRESULT_FR_INVALID_DRIVE: FRESULT = 11;
#[doc = " (11) The logical drive number is invalid"]
pub const FRESULT_FR_NOT_ENABLED: FRESULT = 12;
#[doc = " (12) The volume has no work area"]
pub const FRESULT_FR_NO_FILESYSTEM: FRESULT = 13;
#[doc = " (13) There is no valid FAT volume"]
pub const FRESULT_FR_MKFS_ABORTED: FRESULT = 14;
#[doc = " (14) The f_mkfs() aborted due to any parameter error"]
pub const FRESULT_FR_TIMEOUT: FRESULT = 15;
#[doc = " (15) Could not get a grant to access the volume within defined period"]
pub const FRESULT_FR_LOCKED: FRESULT = 16;
#[doc = " (16) The operation is rejected according to the file sharing policy"]
pub const FRESULT_FR_NOT_ENOUGH_CORE: FRESULT = 17;
#[doc = " (17) LFN working buffer could not be allocated"]
pub const FRESULT_FR_TOO_MANY_OPEN_FILES: FRESULT = 18;
#[doc = " (18) Number of open files > _FS_SHARE"]
pub const FRESULT_FR_INVALID_PARAMETER: FRESULT = 19;
pub type FRESULT = ::core::ffi::c_uint;
pub const _touchEvent_kTouchEventRelease: _touchEvent = 0;
pub const _touchEvent_kTouchEventPress: _touchEvent = 1;
pub const _touchEvent_kTouchEventPressAuto: _touchEvent = 2;
#[doc = " @brief      V5 touch events"]
pub type _touchEvent = ::core::ffi::c_uint;
#[doc = " @brief      V5 touch events"]
pub use self::_touchEvent as V5_TouchEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _V5_TouchStatus {
    pub lastEvent: V5_TouchEvent,
    pub lastXpos: i16,
    pub lastYpos: i16,
    pub pressCount: i32,
    pub releaseCount: i32,
}
pub type V5_TouchStatus = _V5_TouchStatus;
#[doc = " @brief   structure holding image info - used by bmp/png read code"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _v5_image {
    pub width: u16,
    pub height: u16,
    pub data: *mut u32,
    pub p: *mut u32,
}
#[doc = " @brief   structure holding image info - used by bmp/png read code"]
pub type v5_image = _v5_image;
extern "C" {
    pub fn vexDelay(timems: u32);
}
extern "C" {
    pub fn vexLedSet(index: u32, value: V5_DeviceLedColor);
}
extern "C" {
    pub fn vexLedRgbSet(index: u32, color: u32);
}
extern "C" {
    pub fn vexLedGet(index: u32) -> V5_DeviceLedColor;
}
extern "C" {
    pub fn vexLedRgbGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexAdiPortConfigSet(index: u32, port: u32, type_: V5_AdiPortConfiguration);
}
extern "C" {
    pub fn vexAdiPortConfigGet(index: u32, port: u32) -> V5_AdiPortConfiguration;
}
extern "C" {
    pub fn vexAdiValueSet(index: u32, port: u32, value: i32);
}
extern "C" {
    pub fn vexAdiValueGet(index: u32, port: u32) -> i32;
}
extern "C" {
    pub fn vexBumperGet(index: u32) -> V5_DeviceBumperState;
}
extern "C" {
    pub fn vexGyroReset(index: u32);
}
extern "C" {
    pub fn vexGyroHeadingGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexGyroDegreesGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexSonarValueGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexGenericValueGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexMotorVelocitySet(index: u32, velocity: i32);
}
extern "C" {
    pub fn vexMotorVelocityUpdate(index: u32, velocity: i32);
}
extern "C" {
    pub fn vexMotorVoltageSet(index: u32, value: i32);
}
extern "C" {
    pub fn vexMotorVelocityGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexMotorDirectionGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexMotorActualVelocityGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexMotorModeSet(index: u32, mode: V5MotorControlMode);
}
extern "C" {
    pub fn vexMotorModeGet(index: u32) -> V5MotorControlMode;
}
extern "C" {
    pub fn vexMotorPwmSet(index: u32, value: i32);
}
extern "C" {
    pub fn vexMotorPwmGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexMotorCurrentLimitSet(index: u32, value: i32);
}
extern "C" {
    pub fn vexMotorCurrentLimitGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexMotorVoltageLimitSet(index: u32, value: i32);
}
extern "C" {
    pub fn vexMotorVoltageLimitGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexMotorPositionPidSet(index: u32, pid: *mut V5_DeviceMotorPid);
}
extern "C" {
    pub fn vexMotorVelocityPidSet(index: u32, pid: *mut V5_DeviceMotorPid);
}
extern "C" {
    pub fn vexMotorCurrentGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexMotorVoltageGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexMotorPowerGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexMotorTorqueGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexMotorEfficiencyGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexMotorTemperatureGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexMotorOverTempFlagGet(index: u32) -> bool;
}
extern "C" {
    pub fn vexMotorCurrentLimitFlagGet(index: u32) -> bool;
}
extern "C" {
    pub fn vexMotorFaultsGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexMotorZeroVelocityFlagGet(index: u32) -> bool;
}
extern "C" {
    pub fn vexMotorZeroPositionFlagGet(index: u32) -> bool;
}
extern "C" {
    pub fn vexMotorFlagsGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexMotorReverseFlagSet(index: u32, value: bool);
}
extern "C" {
    pub fn vexMotorReverseFlagGet(index: u32) -> bool;
}
extern "C" {
    pub fn vexMotorEncoderUnitsSet(index: u32, units: V5MotorEncoderUnits);
}
extern "C" {
    pub fn vexMotorEncoderUnitsGet(index: u32) -> V5MotorEncoderUnits;
}
extern "C" {
    pub fn vexMotorBrakeModeSet(index: u32, mode: V5MotorBrakeMode);
}
extern "C" {
    pub fn vexMotorBrakeModeGet(index: u32) -> V5MotorBrakeMode;
}
extern "C" {
    pub fn vexMotorPositionSet(index: u32, position: f64);
}
extern "C" {
    pub fn vexMotorPositionGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexMotorPositionRawGet(index: u32, timestamp: *mut u32) -> i32;
}
extern "C" {
    pub fn vexMotorPositionReset(index: u32);
}
extern "C" {
    pub fn vexMotorTargetGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexMotorServoTargetSet(index: u32, position: f64);
}
extern "C" {
    pub fn vexMotorAbsoluteTargetSet(index: u32, position: f64, velocity: i32);
}
extern "C" {
    pub fn vexMotorRelativeTargetSet(index: u32, position: f64, velocity: i32);
}
extern "C" {
    pub fn vexMotorGearingSet(index: u32, value: V5MotorGearset);
}
extern "C" {
    pub fn vexMotorGearingGet(index: u32) -> V5MotorGearset;
}
extern "C" {
    pub fn vexMotorExternalProfileSet(index: u32, position: f64, velocity: i32);
}
extern "C" {
    pub fn vexVisionModeSet(index: u32, mode: V5VisionMode);
}
extern "C" {
    pub fn vexVisionModeGet(index: u32) -> V5VisionMode;
}
extern "C" {
    pub fn vexVisionObjectCountGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexVisionObjectGet(
        index: u32,
        indexObj: u32,
        pObject: *mut V5_DeviceVisionObject,
    ) -> i32;
}
extern "C" {
    pub fn vexVisionSignatureSet(index: u32, pSignature: *mut V5_DeviceVisionSignature);
}
extern "C" {
    pub fn vexVisionSignatureGet(
        index: u32,
        id: u32,
        pSignature: *mut V5_DeviceVisionSignature,
    ) -> bool;
}
extern "C" {
    pub fn vexVisionBrightnessSet(index: u32, percent: u8);
}
extern "C" {
    pub fn vexVisionBrightnessGet(index: u32) -> u8;
}
extern "C" {
    pub fn vexVisionWhiteBalanceModeSet(index: u32, mode: V5VisionWBMode);
}
extern "C" {
    pub fn vexVisionWhiteBalanceModeGet(index: u32) -> V5VisionWBMode;
}
extern "C" {
    pub fn vexVisionWhiteBalanceSet(index: u32, color: V5_DeviceVisionRgb);
}
extern "C" {
    pub fn vexVisionWhiteBalanceGet(index: u32) -> V5_DeviceVisionRgb;
}
extern "C" {
    pub fn vexVisionLedModeSet(index: u32, mode: V5VisionLedMode);
}
extern "C" {
    pub fn vexVisionLedModeGet(index: u32) -> V5VisionLedMode;
}
extern "C" {
    pub fn vexVisionLedBrigntnessSet(index: u32, percent: u8);
}
extern "C" {
    pub fn vexVisionLedBrigntnessGet(index: u32) -> u8;
}
extern "C" {
    pub fn vexVisionLedColorSet(index: u32, color: V5_DeviceVisionRgb);
}
extern "C" {
    pub fn vexVisionLedColorGet(index: u32) -> V5_DeviceVisionRgb;
}
extern "C" {
    pub fn vexVisionWifiModeSet(index: u32, mode: V5VisionWifiMode);
}
extern "C" {
    pub fn vexVisionWifiModeGet(index: u32) -> V5VisionWifiMode;
}
extern "C" {
    pub fn vexImuReset(index: u32);
}
extern "C" {
    pub fn vexImuHeadingGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexImuDegreesGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexImuQuaternionGet(index: u32, data: *mut V5_DeviceImuQuaternion);
}
extern "C" {
    pub fn vexImuAttitudeGet(index: u32, data: *mut V5_DeviceImuAttitude);
}
extern "C" {
    pub fn vexImuRawGyroGet(index: u32, data: *mut V5_DeviceImuRaw);
}
extern "C" {
    pub fn vexImuRawAccelGet(index: u32, data: *mut V5_DeviceImuRaw);
}
extern "C" {
    pub fn vexImuStatusGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexImuModeSet(index: u32, mode: u32);
}
extern "C" {
    pub fn vexImuModeGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexImuDataRateSet(index: u32, rate: u32);
}
extern "C" {
    pub fn vexRangeValueGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexAbsEncReset(index: u32);
}
extern "C" {
    pub fn vexAbsEncPositionSet(index: u32, position: i32);
}
extern "C" {
    pub fn vexAbsEncPositionGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexAbsEncVelocityGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexAbsEncAngleGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexAbsEncReverseFlagSet(index: u32, value: bool);
}
extern "C" {
    pub fn vexAbsEncReverseFlagGet(index: u32) -> bool;
}
extern "C" {
    pub fn vexAbsEncStatusGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexAbsEncDataRateSet(index: u32, rate: u32);
}
extern "C" {
    pub fn vexOpticalHueGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexOpticalSatGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexOpticalBrightnessGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexOpticalProximityGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexOpticalRgbGet(index: u32, data: *mut V5_DeviceOpticalRgb);
}
extern "C" {
    pub fn vexOpticalLedPwmSet(index: u32, value: i32);
}
extern "C" {
    pub fn vexOpticalLedPwmGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexOpticalStatusGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexOpticalRawGet(index: u32, data: *mut V5_DeviceOpticalRaw);
}
extern "C" {
    pub fn vexOpticalModeSet(index: u32, mode: u32);
}
extern "C" {
    pub fn vexOpticalModeGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexOpticalGestureGet(index: u32, pData: *mut V5_DeviceOpticalGesture) -> u32;
}
extern "C" {
    pub fn vexOpticalGestureEnable(index: u32);
}
extern "C" {
    pub fn vexOpticalGestureDisable(index: u32);
}
extern "C" {
    pub fn vexOpticalProximityThreshold(index: u32, value: i32) -> i32;
}
extern "C" {
    pub fn vexOpticalIntegrationTimeSet(index: u32, timems: f64);
}
extern "C" {
    pub fn vexOpticalIntegrationTimeGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexMagnetPowerSet(index: u32, value: i32, time: i32);
}
extern "C" {
    pub fn vexMagnetPowerGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexMagnetPickup(index: u32, duration: V5_DeviceMagnetDuration);
}
extern "C" {
    pub fn vexMagnetDrop(index: u32, duration: V5_DeviceMagnetDuration);
}
extern "C" {
    pub fn vexMagnetTemperatureGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexMagnetCurrentGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexMagnetStatusGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexDistanceDistanceGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexDistanceConfidenceGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexDistanceObjectSizeGet(index: u32) -> i32;
}
extern "C" {
    pub fn vexDistanceObjectVelocityGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexDistanceStatusGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexGpsReset(index: u32);
}
extern "C" {
    pub fn vexGpsHeadingGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexGpsDegreesGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexGpsQuaternionGet(index: u32, data: *mut V5_DeviceGpsQuaternion);
}
extern "C" {
    pub fn vexGpsAttitudeGet(index: u32, data: *mut V5_DeviceGpsAttitude, bRaw: bool);
}
extern "C" {
    pub fn vexGpsRawGyroGet(index: u32, data: *mut V5_DeviceGpsRaw);
}
extern "C" {
    pub fn vexGpsRawAccelGet(index: u32, data: *mut V5_DeviceGpsRaw);
}
extern "C" {
    pub fn vexGpsStatusGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexGpsModeSet(index: u32, mode: u32);
}
extern "C" {
    pub fn vexGpsModeGet(index: u32) -> u32;
}
extern "C" {
    pub fn vexGpsDataRateSet(index: u32, rate: u32);
}
extern "C" {
    pub fn vexGpsOriginSet(index: u32, ox: f64, oy: f64);
}
extern "C" {
    pub fn vexGpsOriginGet(index: u32, ox: *mut f64, oy: *mut f64);
}
extern "C" {
    pub fn vexGpsRotationSet(index: u32, value: f64);
}
extern "C" {
    pub fn vexGpsRotationGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexGpsInitialPositionSet(
        index: u32,
        initial_x: f64,
        initial_y: f64,
        initial_rotation: f64,
    );
}
extern "C" {
    pub fn vexGpsErrorGet(index: u32) -> f64;
}
extern "C" {
    pub fn vexGenericSerialEnable(index: u32, options: i32);
}
extern "C" {
    pub fn vexGenericSerialBaudrate(index: u32, baudrate: i32);
}
extern "C" {
    pub fn vexGenericSerialWriteChar(index: u32, c: u8) -> i32;
}
extern "C" {
    pub fn vexGenericSerialWriteFree(index: u32) -> i32;
}
extern "C" {
    pub fn vexGenericSerialTransmit(index: u32, buffer: *mut u8, length: i32) -> i32;
}
extern "C" {
    pub fn vexGenericSerialReadChar(index: u32) -> i32;
}
extern "C" {
    pub fn vexGenericSerialPeekChar(index: u32) -> i32;
}
extern "C" {
    pub fn vexGenericSerialReceiveAvail(index: u32) -> i32;
}
extern "C" {
    pub fn vexGenericSerialReceive(index: u32, buffer: *mut u8, length: i32) -> i32;
}
extern "C" {
    pub fn vexGenericSerialFlush(index: u32);
}
extern "C" {
    pub fn vexBackgroundProcessing();
}
extern "C" {
    pub fn vexDebug(fmt: *const ::core::ffi::c_char, ...) -> i32;
}
extern "C" {
    pub fn vex_printf(fmt: *const ::core::ffi::c_char, ...) -> i32;
}
extern "C" {
    pub fn vex_sprintf(
        out: *mut ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ...
    ) -> i32;
}
extern "C" {
    pub fn vex_snprintf(
        out: *mut ::core::ffi::c_char,
        max_len: u32,
        format: *const ::core::ffi::c_char,
        ...
    ) -> i32;
}
extern "C" {
    pub fn vex_vsprintf(
        out: *mut ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        args: va_list,
    ) -> i32;
}
extern "C" {
    pub fn vex_vsnprintf(
        out: *mut ::core::ffi::c_char,
        max_len: u32,
        format: *const ::core::ffi::c_char,
        args: va_list,
    ) -> i32;
}
extern "C" {
    pub fn vexSystemTimeGet() -> u32;
}
extern "C" {
    pub fn vexGettime(pTime: *mut time);
}
extern "C" {
    pub fn vexGetdate(pDate: *mut date);
}
extern "C" {
    pub fn vexSystemMemoryDump();
}
extern "C" {
    pub fn vexSystemDigitalIO(pin: u32, value: u32);
}
extern "C" {
    pub fn vexSystemStartupOptions() -> u32;
}
extern "C" {
    pub fn vexSystemExitRequest();
}
extern "C" {
    pub fn vexSystemHighResTimeGet() -> u64;
}
extern "C" {
    pub fn vexSystemPowerupTimeGet() -> u64;
}
extern "C" {
    pub fn vexSystemLinkAddrGet() -> u32;
}
extern "C" {
    pub fn vexSystemUsbStatus() -> u32;
}
extern "C" {
    pub fn vexDevicesGetNumber() -> u32;
}
extern "C" {
    pub fn vexDevicesGetNumberByType(type_: V5_DeviceType) -> u32;
}
extern "C" {
    pub fn vexDevicesGet() -> V5_DeviceT;
}
extern "C" {
    pub fn vexDeviceGetByIndex(index: u32) -> V5_DeviceT;
}
extern "C" {
    pub fn vexDeviceGetStatus(buffer: *mut V5_DeviceType) -> i32;
}
extern "C" {
    pub fn vexDeviceGetTimestamp(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceGetTimestampByIndex(index: i32) -> i32;
}
extern "C" {
    pub fn vexDeviceButtonStateGet() -> u32;
}
extern "C" {
    pub fn vexControllerGet(id: V5_ControllerId, index: V5_ControllerIndex) -> i32;
}
extern "C" {
    pub fn vexControllerConnectionStatusGet(id: V5_ControllerId) -> V5_ControllerStatus;
}
extern "C" {
    pub fn vexControllerTextSet(
        id: V5_ControllerId,
        line: u32,
        col: u32,
        str_: *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn vexDeviceLedSet(device: V5_DeviceT, value: V5_DeviceLedColor);
}
extern "C" {
    pub fn vexDeviceLedRgbSet(device: V5_DeviceT, color: u32);
}
extern "C" {
    pub fn vexDeviceLedGet(device: V5_DeviceT) -> V5_DeviceLedColor;
}
extern "C" {
    pub fn vexDeviceLedRgbGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceAdiPortConfigSet(device: V5_DeviceT, port: u32, type_: V5_AdiPortConfiguration);
}
extern "C" {
    pub fn vexDeviceAdiPortConfigGet(device: V5_DeviceT, port: u32) -> V5_AdiPortConfiguration;
}
extern "C" {
    pub fn vexDeviceAdiValueSet(device: V5_DeviceT, port: u32, value: i32);
}
extern "C" {
    pub fn vexDeviceAdiValueGet(device: V5_DeviceT, port: u32) -> i32;
}
extern "C" {
    pub fn vexDeviceBumperGet(device: V5_DeviceT) -> V5_DeviceBumperState;
}
extern "C" {
    pub fn vexDeviceGyroReset(device: V5_DeviceT);
}
extern "C" {
    pub fn vexDeviceGyroHeadingGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceGyroDegreesGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceSonarValueGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceGenericValueGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceMotorVelocitySet(device: V5_DeviceT, velocity: i32);
}
extern "C" {
    pub fn vexDeviceMotorVelocityUpdate(device: V5_DeviceT, velocity: i32);
}
extern "C" {
    pub fn vexDeviceMotorVoltageSet(device: V5_DeviceT, value: i32);
}
extern "C" {
    pub fn vexDeviceMotorVelocityGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceMotorActualVelocityGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceMotorDirectionGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceMotorModeSet(device: V5_DeviceT, mode: V5MotorControlMode);
}
extern "C" {
    pub fn vexDeviceMotorModeGet(device: V5_DeviceT) -> V5MotorControlMode;
}
extern "C" {
    pub fn vexDeviceMotorPwmSet(device: V5_DeviceT, value: i32);
}
extern "C" {
    pub fn vexDeviceMotorPwmGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceMotorCurrentLimitSet(device: V5_DeviceT, value: i32);
}
extern "C" {
    pub fn vexDeviceMotorCurrentLimitGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceMotorVoltageLimitSet(device: V5_DeviceT, value: i32);
}
extern "C" {
    pub fn vexDeviceMotorVoltageLimitGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceMotorPositionPidSet(device: V5_DeviceT, pid: *mut V5_DeviceMotorPid);
}
extern "C" {
    pub fn vexDeviceMotorVelocityPidSet(device: V5_DeviceT, pid: *mut V5_DeviceMotorPid);
}
extern "C" {
    pub fn vexDeviceMotorCurrentGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceMotorVoltageGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceMotorPowerGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceMotorTorqueGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceMotorEfficiencyGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceMotorTemperatureGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceMotorOverTempFlagGet(device: V5_DeviceT) -> bool;
}
extern "C" {
    pub fn vexDeviceMotorCurrentLimitFlagGet(device: V5_DeviceT) -> bool;
}
extern "C" {
    pub fn vexDeviceMotorFaultsGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceMotorZeroVelocityFlagGet(device: V5_DeviceT) -> bool;
}
extern "C" {
    pub fn vexDeviceMotorZeroPositionFlagGet(device: V5_DeviceT) -> bool;
}
extern "C" {
    pub fn vexDeviceMotorFlagsGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceMotorReverseFlagSet(device: V5_DeviceT, value: bool);
}
extern "C" {
    pub fn vexDeviceMotorReverseFlagGet(device: V5_DeviceT) -> bool;
}
extern "C" {
    pub fn vexDeviceMotorEncoderUnitsSet(device: V5_DeviceT, units: V5MotorEncoderUnits);
}
extern "C" {
    pub fn vexDeviceMotorEncoderUnitsGet(device: V5_DeviceT) -> V5MotorEncoderUnits;
}
extern "C" {
    pub fn vexDeviceMotorBrakeModeSet(device: V5_DeviceT, mode: V5MotorBrakeMode);
}
extern "C" {
    pub fn vexDeviceMotorBrakeModeGet(device: V5_DeviceT) -> V5MotorBrakeMode;
}
extern "C" {
    pub fn vexDeviceMotorPositionSet(device: V5_DeviceT, position: f64);
}
extern "C" {
    pub fn vexDeviceMotorPositionGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceMotorPositionRawGet(device: V5_DeviceT, timestamp: *mut u32) -> i32;
}
extern "C" {
    pub fn vexDeviceMotorPositionReset(device: V5_DeviceT);
}
extern "C" {
    pub fn vexDeviceMotorTargetGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceMotorServoTargetSet(device: V5_DeviceT, position: f64);
}
extern "C" {
    pub fn vexDeviceMotorAbsoluteTargetSet(device: V5_DeviceT, position: f64, velocity: i32);
}
extern "C" {
    pub fn vexDeviceMotorRelativeTargetSet(device: V5_DeviceT, position: f64, velocity: i32);
}
extern "C" {
    pub fn vexDeviceMotorGearingSet(device: V5_DeviceT, value: V5MotorGearset);
}
extern "C" {
    pub fn vexDeviceMotorGearingGet(device: V5_DeviceT) -> V5MotorGearset;
}
extern "C" {
    pub fn vexDeviceMotorExternalProfileSet(device: V5_DeviceT, position: f64, velocity: i32);
}
extern "C" {
    pub fn vexDeviceVisionModeSet(device: V5_DeviceT, mode: V5VisionMode);
}
extern "C" {
    pub fn vexDeviceVisionModeGet(device: V5_DeviceT) -> V5VisionMode;
}
extern "C" {
    pub fn vexDeviceVisionObjectCountGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceVisionObjectGet(
        device: V5_DeviceT,
        indexObj: u32,
        pObject: *mut V5_DeviceVisionObject,
    ) -> i32;
}
extern "C" {
    pub fn vexDeviceVisionSignatureSet(
        device: V5_DeviceT,
        pSignature: *mut V5_DeviceVisionSignature,
    );
}
extern "C" {
    pub fn vexDeviceVisionSignatureGet(
        device: V5_DeviceT,
        id: u32,
        pSignature: *mut V5_DeviceVisionSignature,
    ) -> bool;
}
extern "C" {
    pub fn vexDeviceVisionBrightnessSet(device: V5_DeviceT, percent: u8);
}
extern "C" {
    pub fn vexDeviceVisionBrightnessGet(device: V5_DeviceT) -> u8;
}
extern "C" {
    pub fn vexDeviceVisionWhiteBalanceModeSet(device: V5_DeviceT, mode: V5VisionWBMode);
}
extern "C" {
    pub fn vexDeviceVisionWhiteBalanceModeGet(device: V5_DeviceT) -> V5VisionWBMode;
}
extern "C" {
    pub fn vexDeviceVisionWhiteBalanceSet(device: V5_DeviceT, color: V5_DeviceVisionRgb);
}
extern "C" {
    pub fn vexDeviceVisionWhiteBalanceGet(device: V5_DeviceT) -> V5_DeviceVisionRgb;
}
extern "C" {
    pub fn vexDeviceVisionLedModeSet(device: V5_DeviceT, mode: V5VisionLedMode);
}
extern "C" {
    pub fn vexDeviceVisionLedModeGet(device: V5_DeviceT) -> V5VisionLedMode;
}
extern "C" {
    pub fn vexDeviceVisionLedBrigntnessSet(device: V5_DeviceT, percent: u8);
}
extern "C" {
    pub fn vexDeviceVisionLedBrigntnessGet(device: V5_DeviceT) -> u8;
}
extern "C" {
    pub fn vexDeviceVisionLedColorSet(device: V5_DeviceT, color: V5_DeviceVisionRgb);
}
extern "C" {
    pub fn vexDeviceVisionLedColorGet(device: V5_DeviceT) -> V5_DeviceVisionRgb;
}
extern "C" {
    pub fn vexDeviceVisionWifiModeSet(device: V5_DeviceT, mode: V5VisionWifiMode);
}
extern "C" {
    pub fn vexDeviceVisionWifiModeGet(device: V5_DeviceT) -> V5VisionWifiMode;
}
extern "C" {
    pub fn vexDeviceImuReset(device: V5_DeviceT);
}
extern "C" {
    pub fn vexDeviceImuHeadingGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceImuDegreesGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceImuQuaternionGet(device: V5_DeviceT, data: *mut V5_DeviceImuQuaternion);
}
extern "C" {
    pub fn vexDeviceImuAttitudeGet(device: V5_DeviceT, data: *mut V5_DeviceImuAttitude);
}
extern "C" {
    pub fn vexDeviceImuRawGyroGet(device: V5_DeviceT, data: *mut V5_DeviceImuRaw);
}
extern "C" {
    pub fn vexDeviceImuRawAccelGet(device: V5_DeviceT, data: *mut V5_DeviceImuRaw);
}
extern "C" {
    pub fn vexDeviceImuStatusGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceImuModeSet(device: V5_DeviceT, mode: u32);
}
extern "C" {
    pub fn vexDeviceImuModeGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceImuDataRateSet(device: V5_DeviceT, rate: u32);
}
extern "C" {
    pub fn vexDeviceRangeValueGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceAbsEncReset(device: V5_DeviceT);
}
extern "C" {
    pub fn vexDeviceAbsEncPositionSet(device: V5_DeviceT, position: i32);
}
extern "C" {
    pub fn vexDeviceAbsEncPositionGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceAbsEncVelocityGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceAbsEncAngleGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceAbsEncReverseFlagSet(device: V5_DeviceT, value: bool);
}
extern "C" {
    pub fn vexDeviceAbsEncReverseFlagGet(device: V5_DeviceT) -> bool;
}
extern "C" {
    pub fn vexDeviceAbsEncStatusGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceAbsEncDataRateSet(device: V5_DeviceT, rate: u32);
}
extern "C" {
    pub fn vexDeviceOpticalHueGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceOpticalSatGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceOpticalBrightnessGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceOpticalProximityGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceOpticalRgbGet(device: V5_DeviceT, data: *mut V5_DeviceOpticalRgb);
}
extern "C" {
    pub fn vexDeviceOpticalLedPwmSet(device: V5_DeviceT, value: i32);
}
extern "C" {
    pub fn vexDeviceOpticalLedPwmGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceOpticalStatusGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceOpticalRawGet(device: V5_DeviceT, data: *mut V5_DeviceOpticalRaw);
}
extern "C" {
    pub fn vexDeviceOpticalModeSet(device: V5_DeviceT, mode: u32);
}
extern "C" {
    pub fn vexDeviceOpticalModeGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceOpticalGestureGet(arg1: V5_DeviceT, pData: *mut V5_DeviceOpticalGesture)
        -> u32;
}
extern "C" {
    pub fn vexDeviceOpticalGestureEnable(arg1: V5_DeviceT);
}
extern "C" {
    pub fn vexDeviceOpticalGestureDisable(arg1: V5_DeviceT);
}
extern "C" {
    pub fn vexDeviceOpticalProximityThreshold(device: V5_DeviceT, value: i32) -> i32;
}
extern "C" {
    pub fn vexDeviceOpticalIntegrationTimeSet(device: V5_DeviceT, timeMs: f64);
}
extern "C" {
    pub fn vexDeviceOpticalIntegrationTimeGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceMagnetPowerSet(device: V5_DeviceT, value: i32, time: i32);
}
extern "C" {
    pub fn vexDeviceMagnetPowerGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceMagnetPickup(device: V5_DeviceT, duration: V5_DeviceMagnetDuration);
}
extern "C" {
    pub fn vexDeviceMagnetDrop(device: V5_DeviceT, duration: V5_DeviceMagnetDuration);
}
extern "C" {
    pub fn vexDeviceMagnetTemperatureGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceMagnetCurrentGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceMagnetStatusGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceDistanceDistanceGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceDistanceConfidenceGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceDistanceObjectSizeGet(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceDistanceObjectVelocityGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceDistanceStatusGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceGpsReset(device: V5_DeviceT);
}
extern "C" {
    pub fn vexDeviceGpsHeadingGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceGpsDegreesGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceGpsQuaternionGet(device: V5_DeviceT, data: *mut V5_DeviceGpsQuaternion);
}
extern "C" {
    pub fn vexDeviceGpsAttitudeGet(device: V5_DeviceT, data: *mut V5_DeviceGpsAttitude, bRaw: bool);
}
extern "C" {
    pub fn vexDeviceGpsRawGyroGet(device: V5_DeviceT, data: *mut V5_DeviceGpsRaw);
}
extern "C" {
    pub fn vexDeviceGpsRawAccelGet(device: V5_DeviceT, data: *mut V5_DeviceGpsRaw);
}
extern "C" {
    pub fn vexDeviceGpsStatusGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceGpsModeSet(device: V5_DeviceT, mode: u32);
}
extern "C" {
    pub fn vexDeviceGpsModeGet(device: V5_DeviceT) -> u32;
}
extern "C" {
    pub fn vexDeviceGpsDataRateSet(device: V5_DeviceT, rate: u32);
}
extern "C" {
    pub fn vexDeviceGpsOriginSet(device: V5_DeviceT, ox: f64, oy: f64);
}
extern "C" {
    pub fn vexDeviceGpsOriginGet(device: V5_DeviceT, ox: *mut f64, oy: *mut f64);
}
extern "C" {
    pub fn vexDeviceGpsRotationSet(device: V5_DeviceT, value: f64);
}
extern "C" {
    pub fn vexDeviceGpsRotationGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceGpsInitialPositionSet(
        device: V5_DeviceT,
        initial_x: f64,
        initial_y: f64,
        initial_rotation: f64,
    );
}
extern "C" {
    pub fn vexDeviceGpsErrorGet(device: V5_DeviceT) -> f64;
}
extern "C" {
    pub fn vexDeviceGenericSerialEnable(device: V5_DeviceT, options: i32);
}
extern "C" {
    pub fn vexDeviceGenericSerialBaudrate(device: V5_DeviceT, baudrate: i32);
}
extern "C" {
    pub fn vexDeviceGenericSerialWriteChar(device: V5_DeviceT, c: u8) -> i32;
}
extern "C" {
    pub fn vexDeviceGenericSerialWriteFree(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceGenericSerialTransmit(device: V5_DeviceT, buffer: *mut u8, length: i32) -> i32;
}
extern "C" {
    pub fn vexDeviceGenericSerialReadChar(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceGenericSerialPeekChar(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceGenericSerialReceiveAvail(device: V5_DeviceT) -> i32;
}
extern "C" {
    pub fn vexDeviceGenericSerialReceive(device: V5_DeviceT, buffer: *mut u8, length: i32) -> i32;
}
extern "C" {
    pub fn vexDeviceGenericSerialFlush(device: V5_DeviceT);
}
extern "C" {
    pub fn vexDisplayForegroundColor(col: u32);
}
extern "C" {
    pub fn vexDisplayBackgroundColor(col: u32);
}
extern "C" {
    pub fn vexDisplayForegroundColorGet() -> u32;
}
extern "C" {
    pub fn vexDisplayBackgroundColorGet() -> u32;
}
extern "C" {
    pub fn vexDisplayErase();
}
extern "C" {
    pub fn vexDisplayScroll(nStartLine: i32, nLines: i32);
}
extern "C" {
    pub fn vexDisplayScrollRect(x1: i32, y1: i32, x2: i32, y2: i32, nLines: i32);
}
extern "C" {
    pub fn vexDisplayCopyRect(x1: i32, y1: i32, x2: i32, y2: i32, pSrc: *mut u32, srcStride: i32);
}
extern "C" {
    pub fn vexDisplayPixelSet(x: u32, y: u32);
}
extern "C" {
    pub fn vexDisplayPixelClear(x: u32, y: u32);
}
extern "C" {
    pub fn vexDisplayLineDraw(x1: i32, y1: i32, x2: i32, y2: i32);
}
extern "C" {
    pub fn vexDisplayLineClear(x1: i32, y1: i32, x2: i32, y2: i32);
}
extern "C" {
    pub fn vexDisplayRectDraw(x1: i32, y1: i32, x2: i32, y2: i32);
}
extern "C" {
    pub fn vexDisplayRectClear(x1: i32, y1: i32, x2: i32, y2: i32);
}
extern "C" {
    pub fn vexDisplayRectFill(x1: i32, y1: i32, x2: i32, y2: i32);
}
extern "C" {
    pub fn vexDisplayCircleDraw(xc: i32, yc: i32, radius: i32);
}
extern "C" {
    pub fn vexDisplayCircleClear(xc: i32, yc: i32, radius: i32);
}
extern "C" {
    pub fn vexDisplayCircleFill(xc: i32, yc: i32, radius: i32);
}
extern "C" {
    pub fn vexDisplayPrintf(
        xpos: i32,
        ypos: i32,
        bOpaque: u32,
        format: *const ::core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn vexDisplayString(nLineNumber: i32, format: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn vexDisplayStringAt(xpos: i32, ypos: i32, format: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn vexDisplayBigString(nLineNumber: i32, format: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn vexDisplayBigStringAt(xpos: i32, ypos: i32, format: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn vexDisplaySmallStringAt(xpos: i32, ypos: i32, format: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn vexDisplayCenteredString(nLineNumber: i32, format: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn vexDisplayBigCenteredString(nLineNumber: i32, format: *const ::core::ffi::c_char, ...);
}
extern "C" {
    pub fn vexDisplayVPrintf(
        xpos: i32,
        ypos: i32,
        bOpaque: u32,
        format: *const ::core::ffi::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn vexDisplayVString(nLineNumber: i32, format: *const ::core::ffi::c_char, args: va_list);
}
extern "C" {
    pub fn vexDisplayVStringAt(
        xpos: i32,
        ypos: i32,
        format: *const ::core::ffi::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn vexDisplayVBigString(
        nLineNumber: i32,
        format: *const ::core::ffi::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn vexDisplayVBigStringAt(
        xpos: i32,
        ypos: i32,
        format: *const ::core::ffi::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn vexDisplayVSmallStringAt(
        xpos: i32,
        ypos: i32,
        format: *const ::core::ffi::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn vexDisplayVCenteredString(
        nLineNumber: i32,
        format: *const ::core::ffi::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn vexDisplayVBigCenteredString(
        nLineNumber: i32,
        format: *const ::core::ffi::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn vexDisplayTextSize(n: u32, d: u32);
}
extern "C" {
    pub fn vexDisplayFontNamedSet(pFontName: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn vexDisplayStringWidthGet(pString: *const ::core::ffi::c_char) -> i32;
}
extern "C" {
    pub fn vexDisplayStringHeightGet(pString: *const ::core::ffi::c_char) -> i32;
}
extern "C" {
    pub fn vexDisplayRender(bVsyncWait: bool, bRunScheduler: bool) -> bool;
}
extern "C" {
    pub fn vexDisplayDoubleBufferDisable();
}
extern "C" {
    pub fn vexDisplayClipRegionSet(x1: i32, y1: i32, x2: i32, y2: i32);
}
extern "C" {
    pub fn vexDisplayClipRegionClear();
}
extern "C" {
    pub fn vexImageBmpRead(ibuf: *const u8, oBuf: *mut v5_image, maxw: u32, maxh: u32) -> u32;
}
extern "C" {
    pub fn vexImagePngRead(
        ibuf: *const u8,
        oBuf: *mut v5_image,
        maxw: u32,
        maxh: u32,
        ibuflen: u32,
    ) -> u32;
}
extern "C" {
    pub fn vexScratchMemoryPtr(ptr: *mut *mut ::core::ffi::c_void) -> i32;
}
extern "C" {
    pub fn vexScratchMemoryLock() -> bool;
}
extern "C" {
    pub fn vexScratchMemoryUnlock();
}
extern "C" {
    pub fn vexFileMountSD() -> FRESULT;
}
extern "C" {
    pub fn vexFileDirectoryGet(
        path: *const ::core::ffi::c_char,
        buffer: *mut ::core::ffi::c_char,
        len: u32,
    ) -> FRESULT;
}
extern "C" {
    pub fn vexFileOpen(
        filename: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
    ) -> *mut FIL;
}
extern "C" {
    pub fn vexFileOpenWrite(filename: *const ::core::ffi::c_char) -> *mut FIL;
}
extern "C" {
    pub fn vexFileOpenCreate(filename: *const ::core::ffi::c_char) -> *mut FIL;
}
extern "C" {
    pub fn vexFileClose(fdp: *mut FIL);
}
extern "C" {
    pub fn vexFileRead(buf: *mut ::core::ffi::c_char, size: u32, nItems: u32, fdp: *mut FIL)
        -> i32;
}
extern "C" {
    pub fn vexFileWrite(
        buf: *mut ::core::ffi::c_char,
        size: u32,
        nItems: u32,
        fdp: *mut FIL,
    ) -> i32;
}
extern "C" {
    pub fn vexFileSize(fdp: *mut FIL) -> i32;
}
extern "C" {
    pub fn vexFileSeek(fdp: *mut FIL, offset: u32, whence: i32) -> FRESULT;
}
extern "C" {
    pub fn vexFileDriveStatus(drive: u32) -> bool;
}
extern "C" {
    pub fn vexFileTell(fdp: *mut FIL) -> i32;
}
extern "C" {
    pub fn vexFileSync(fdp: *mut FIL);
}
extern "C" {
    pub fn vexFileStatus(filename: *const ::core::ffi::c_char) -> u32;
}
extern "C" {
    pub fn vexSerialWriteChar(channel: u32, c: u8) -> i32;
}
extern "C" {
    pub fn vexSerialWriteBuffer(channel: u32, data: *mut u8, data_len: u32) -> i32;
}
extern "C" {
    pub fn vexSerialReadChar(channel: u32) -> i32;
}
extern "C" {
    pub fn vexSerialPeekChar(channel: u32) -> i32;
}
extern "C" {
    pub fn vexSerialWriteFree(channel: u32) -> i32;
}
extern "C" {
    pub fn vexSystemTimerStop();
}
extern "C" {
    pub fn vexSystemTimerClearInterrupt();
}
extern "C" {
    pub fn vexSystemTimerReinitForRtos(
        priority: u32,
        handler: ::core::option::Option<unsafe extern "C" fn(data: *mut ::core::ffi::c_void)>,
    ) -> i32;
}
extern "C" {
    pub fn vexSystemApplicationIRQHandler(ulICCIAR: u32);
}
extern "C" {
    pub fn vexSystemWatchdogReinitRtos() -> i32;
}
extern "C" {
    pub fn vexSystemWatchdogGet() -> u32;
}
extern "C" {
    pub fn vexSystemBoot();
}
extern "C" {
    pub fn vexSystemUndefinedException();
}
extern "C" {
    pub fn vexSystemFIQInterrupt();
}
extern "C" {
    pub fn vexSystemIQRQnterrupt();
}
extern "C" {
    pub fn vexSystemSWInterrupt();
}
extern "C" {
    pub fn vexSystemDataAbortInterrupt();
}
extern "C" {
    pub fn vexSystemPrefetchAbortInterrupt();
}
extern "C" {
    pub fn vexTouchUserCallbackSet(
        callback: ::core::option::Option<
            unsafe extern "C" fn(arg1: V5_TouchEvent, arg2: i32, arg3: i32),
        >,
    );
}
extern "C" {
    pub fn vexTouchDataGet(status: *mut V5_TouchStatus) -> bool;
}
extern "C" {
    pub fn vexSystemVersion() -> u32;
}
extern "C" {
    pub fn vexStdlibVersion() -> u32;
}
extern "C" {
    pub fn vexSdkVersion() -> u32;
}
extern "C" {
    pub fn vexStdlibVersionLinked() -> u32;
}
extern "C" {
    pub fn vexStdlibVersionVerify() -> bool;
}
extern "C" {
    pub fn vexCompetitionStatus() -> u32;
}
extern "C" {
    pub fn vexCompetitionControl(data: u32);
}
extern "C" {
    pub fn vexBatteryVoltageGet() -> i32;
}
extern "C" {
    pub fn vexBatteryCurrentGet() -> i32;
}
extern "C" {
    pub fn vexBatteryTemperatureGet() -> f64;
}
extern "C" {
    pub fn vexBatteryCapacityGet() -> f64;
}
#[repr(C)]
#[derive(Debug)]
pub struct vex_mevent {
    pub _event_id: ::core::ffi::c_int,
    pub _index: ::core::ffi::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6meventC1Ejj"]
    pub fn vex_mevent_mevent(this: *mut vex_mevent, index: u32, id: u32);
}
impl vex_mevent {
    #[inline]
    pub unsafe fn new(index: u32, id: u32) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_mevent_mevent(__bindgen_tmp.as_mut_ptr(), index, id);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief A percentage unit that represents a value from 0% to 100%"]
pub const vex_percentUnits_pct: vex_percentUnits = 0;
#[doc = "@brief The measurement units for percentage values."]
pub type vex_percentUnits = ::core::ffi::c_int;
#[doc = " @brief A time unit that is measured in seconds."]
pub const vex_timeUnits_sec: vex_timeUnits = 0;
#[doc = " @brief A time unit that is measured in milliseconds."]
pub const vex_timeUnits_msec: vex_timeUnits = 1;
#[doc = "@brief The measurement units for time values."]
pub type vex_timeUnits = ::core::ffi::c_int;
#[doc = " @brief A current unit that is measured in amps."]
pub const vex_currentUnits_amp: vex_currentUnits = 0;
#[doc = "@brief The measurement units for current values."]
pub type vex_currentUnits = ::core::ffi::c_int;
#[doc = " @brief A voltage unit that is measured in volts."]
pub const vex_voltageUnits_volt: vex_voltageUnits = 0;
#[doc = " @brief The measurement units for power values millivolts."]
pub const vex_voltageUnits_mV: vex_voltageUnits = 1;
#[doc = "@brief The measurement units for voltage values."]
pub type vex_voltageUnits = ::core::ffi::c_int;
#[doc = " @brief A power unit that is measured in watts."]
pub const vex_powerUnits_watt: vex_powerUnits = 0;
#[doc = "@brief The measurement units for power values."]
pub type vex_powerUnits = ::core::ffi::c_int;
#[doc = " @brief A torque unit that is measured in Newton Meters."]
pub const vex_torqueUnits_Nm: vex_torqueUnits = 0;
#[doc = " @brief A torque unit that is measured in Inch Pounds."]
pub const vex_torqueUnits_InLb: vex_torqueUnits = 1;
#[doc = "@brief The measurement units for torque values."]
pub type vex_torqueUnits = ::core::ffi::c_int;
#[doc = " @brief A rotation unit that is measured in degrees."]
pub const vex_rotationUnits_deg: vex_rotationUnits = 0;
#[doc = " @brief A rotation unit that is measured in revolutions."]
pub const vex_rotationUnits_rev: vex_rotationUnits = 1;
#[doc = " @brief A rotation unit that is measured in raw data form."]
pub const vex_rotationUnits_raw: vex_rotationUnits = 99;
#[doc = "@brief The measurement units for rotation values."]
pub type vex_rotationUnits = ::core::ffi::c_int;
#[doc = " @brief A velocity unit that is measured in percentage."]
pub const vex_velocityUnits_pct: vex_velocityUnits = 0;
#[doc = " @brief A velocity unit that is measured in rotations per minute."]
pub const vex_velocityUnits_rpm: vex_velocityUnits = 1;
#[doc = " @brief A velocity unit that is measured in degrees per second."]
pub const vex_velocityUnits_dps: vex_velocityUnits = 2;
#[doc = "@brief The measurement units for velocity values."]
pub type vex_velocityUnits = ::core::ffi::c_int;
#[doc = " @brief A distance unit that is measured in millimeters."]
pub const vex_distanceUnits_mm: vex_distanceUnits = 0;
#[doc = " @brief A distance unit that is measured in inches."]
pub const vex_distanceUnits_in_: vex_distanceUnits = 1;
#[doc = " @brief A distance unit that is measured in centimeters."]
pub const vex_distanceUnits_cm: vex_distanceUnits = 2;
#[doc = "@brief The measurement units for distance values."]
pub type vex_distanceUnits = ::core::ffi::c_int;
#[doc = " @brief An analog unit that is measured in percentage."]
pub const vex_analogUnits_pct: vex_analogUnits = 0;
#[doc = " @brief An analog unit that is measured in an 8-bit analog value (a value with 256 possible states)."]
pub const vex_analogUnits_range8bit: vex_analogUnits = 1;
#[doc = " @brief An analog unit that is measured in a 10-bit analog value (a value with 1024 possible states)."]
pub const vex_analogUnits_range10bit: vex_analogUnits = 2;
#[doc = " @brief An analog unit that is measured in a 12-bit analog value (a value with 4096 possible states)."]
pub const vex_analogUnits_range12bit: vex_analogUnits = 3;
#[doc = " @brief An analog unit that is measured in millivolts."]
pub const vex_analogUnits_mV: vex_analogUnits = 4;
#[doc = "@brief The measurement units for analog values."]
pub type vex_analogUnits = ::core::ffi::c_int;
#[doc = " @brief A temperature unit that is measured in celsius."]
pub const vex_temperatureUnits_celsius: vex_temperatureUnits = 0;
#[doc = " @brief A temperature unit that is measured in fahrenheit."]
pub const vex_temperatureUnits_fahrenheit: vex_temperatureUnits = 1;
#[doc = "@brief The measurement units for temperature values."]
pub type vex_temperatureUnits = ::core::ffi::c_int;
#[doc = " @brief A direction unit that is defined as forward."]
pub const vex_directionType_fwd: vex_directionType = 0;
#[doc = " @brief A direction unit that is defined as backward."]
pub const vex_directionType_rev: vex_directionType = 1;
#[doc = " @brief A direction unit that is defined as backward."]
pub const vex_directionType_undefined: vex_directionType = 2;
#[doc = "@brief The defined units for direction values."]
pub type vex_directionType = ::core::ffi::c_int;
#[doc = " @brief A turn unit that is defined as left turning."]
pub const vex_turnType_left: vex_turnType = 0;
#[doc = " @brief A turn unit that is defined as right turning."]
pub const vex_turnType_right: vex_turnType = 1;
#[doc = "@brief The defined units for turn values."]
pub type vex_turnType = ::core::ffi::c_int;
#[doc = " @brief A brake unit that is defined as coast."]
pub const vex_brakeType_coast: vex_brakeType = 0;
#[doc = " @brief A brake unit that is defined as brake."]
pub const vex_brakeType_brake: vex_brakeType = 1;
#[doc = " @brief A brake unit that is defined as hold."]
pub const vex_brakeType_hold: vex_brakeType = 2;
#[doc = " @brief A brake unit that is defined as hold."]
pub const vex_brakeType_undefined: vex_brakeType = 3;
#[doc = "@brief The defined units for brake values."]
pub type vex_brakeType = ::core::ffi::c_int;
#[doc = " @brief A gear unit that is defined as the red 36:1 gear cartridge used in V5 Smart Motors."]
pub const vex_gearSetting_ratio36_1: vex_gearSetting = 0;
#[doc = " @brief A gear unit that is defined as the green 18:1 gear cartridge used in V5 Smart Motors."]
pub const vex_gearSetting_ratio18_1: vex_gearSetting = 1;
#[doc = " @brief A gear unit that is defined as the blue 6:1 gear cartridge used in V5 Smart Motors."]
pub const vex_gearSetting_ratio6_1: vex_gearSetting = 2;
#[doc = "@brief The defined units for gear values."]
pub type vex_gearSetting = ::core::ffi::c_int;
#[doc = " @brief A font unit that is defined as mono20."]
pub const vex_fontType_mono20: vex_fontType = 0;
#[doc = " @brief A font unit that is defined as mono30."]
pub const vex_fontType_mono30: vex_fontType = 1;
#[doc = " @brief A font unit that is defined as mono40."]
pub const vex_fontType_mono40: vex_fontType = 2;
#[doc = " @brief A font unit that is defined as mono60."]
pub const vex_fontType_mono60: vex_fontType = 3;
#[doc = " @brief A font unit that is defined as prop20."]
pub const vex_fontType_prop20: vex_fontType = 4;
#[doc = " @brief A font unit that is defined as prop30."]
pub const vex_fontType_prop30: vex_fontType = 5;
#[doc = " @brief A font unit that is defined as prop40."]
pub const vex_fontType_prop40: vex_fontType = 6;
#[doc = " @brief A font unit that is defined as prop60."]
pub const vex_fontType_prop60: vex_fontType = 7;
#[doc = " @brief A font unit that is defined as mono15."]
pub const vex_fontType_mono15: vex_fontType = 8;
#[doc = " @brief A font unit that is defined as mono12."]
pub const vex_fontType_mono12: vex_fontType = 9;
#[doc = " @brief A font unit that is defined as cjk16."]
pub const vex_fontType_cjk16: vex_fontType = 10;
#[doc = "@brief The defined units for font values."]
pub type vex_fontType = ::core::ffi::c_int;
#[doc = " @brief A triport unit that is defined as an analog input."]
pub const vex_triportType_analogInput: vex_triportType = 0;
#[doc = " @brief A triport unit that is defined as an analog output."]
pub const vex_triportType_analogOutput: vex_triportType = 1;
#[doc = " @brief A triport unit that is defined as a digital input."]
pub const vex_triportType_digitalInput: vex_triportType = 2;
#[doc = " @brief A triport unit that is defined as a digital output."]
pub const vex_triportType_digitalOutput: vex_triportType = 3;
#[doc = " @brief A triport unit that is defined as a button."]
pub const vex_triportType_button: vex_triportType = 4;
#[doc = " @brief A triport unit that is defined as a potentiometer."]
pub const vex_triportType_potentiometer: vex_triportType = 5;
#[doc = " @brief A triport unit that is defined as a line sensor."]
pub const vex_triportType_lineSensor: vex_triportType = 6;
#[doc = " @brief A triport unit that is defined as a light sensor."]
pub const vex_triportType_lightSensor: vex_triportType = 7;
#[doc = " @brief A triport unit that is defined as a gyro."]
pub const vex_triportType_gyro: vex_triportType = 8;
#[doc = " @brief A triport unit that is defined as an accelerometer."]
pub const vex_triportType_accelerometer: vex_triportType = 9;
#[doc = " @brief A triport unit that is defined as a motor."]
pub const vex_triportType_motor: vex_triportType = 10;
#[doc = " @brief A triport unit that is defined as a servo."]
pub const vex_triportType_servo: vex_triportType = 11;
#[doc = " @brief A triport unit that is defined as a quadrature encoder."]
pub const vex_triportType_quadEncoder: vex_triportType = 12;
#[doc = " @brief A triport unit that is defined as a sonar."]
pub const vex_triportType_sonar: vex_triportType = 13;
#[doc = " @brief A triport unit that is defined as a motor with slew rate control."]
pub const vex_triportType_motorS: vex_triportType = 14;
#[doc = "@brief The defined units for triport devices."]
pub type vex_triportType = ::core::ffi::c_int;
#[doc = " @brief A controller unit defined as a primary controller."]
pub const vex_controllerType_primary: vex_controllerType = 0;
#[doc = " @brief A controller unit defined as a partner controller."]
pub const vex_controllerType_partner: vex_controllerType = 1;
#[doc = "@brief The defined units for controller devices."]
pub type vex_controllerType = ::core::ffi::c_int;
pub const vex_axisType_xaxis: vex_axisType = 0;
pub const vex_axisType_yaxis: vex_axisType = 1;
pub const vex_axisType_zaxis: vex_axisType = 2;
#[doc = "@brief The defined units for inertial sensor axis."]
pub type vex_axisType = ::core::ffi::c_int;
pub const vex_orientationType_roll: vex_orientationType = 0;
pub const vex_orientationType_pitch: vex_orientationType = 1;
pub const vex_orientationType_yaw: vex_orientationType = 2;
#[doc = "@brief The defined units for inertial sensor orientation."]
pub type vex_orientationType = ::core::ffi::c_int;
pub const vex_sizeType_none: vex_sizeType = 0;
pub const vex_sizeType_small: vex_sizeType = 1;
pub const vex_sizeType_medium: vex_sizeType = 2;
pub const vex_sizeType_large: vex_sizeType = 3;
#[doc = "@brief The defined units for distance sensor object size."]
pub type vex_sizeType = ::core::ffi::c_int;
pub const vex_ledState_off: vex_ledState = 0;
pub const vex_ledState_on: vex_ledState = 1;
#[doc = "@brief The defined units for optical sensor led state."]
pub type vex_ledState = ::core::ffi::c_int;
pub const vex_gestureType_none: vex_gestureType = 0;
pub const vex_gestureType_up: vex_gestureType = 1;
pub const vex_gestureType_down: vex_gestureType = 2;
pub const vex_gestureType_left: vex_gestureType = 3;
pub const vex_gestureType_right: vex_gestureType = 4;
#[doc = "@brief The defined units for optical sensor gesture types."]
pub type vex_gestureType = ::core::ffi::c_int;
pub const vex_linkType_undefined: vex_linkType = 0;
#[doc = " @brief A vexlink type that is defined as the manager radio."]
pub const vex_linkType_manager: vex_linkType = 1;
#[doc = " @brief A vexlink type that is defined as the worker radio."]
pub const vex_linkType_worker: vex_linkType = 2;
#[doc = " @brief A vexlink type that is defined as a raw unmanaged link."]
pub const vex_linkType_raw: vex_linkType = 3;
#[doc = "@brief The defined units for vexlink types."]
pub type vex_linkType = ::core::ffi::c_int;
#[doc = " @brief Use the color class to create Color objects."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_color {
    pub _argb: u32,
    pub _transparent: bool,
}
extern "C" {
    #[doc = "@brief Represents the color black."]
    #[link_name = "\u{1}_ZN3vex5color5blackE"]
    pub static vex_color_black: vex_color;
}
extern "C" {
    #[doc = "@brief Represents the color white."]
    #[link_name = "\u{1}_ZN3vex5color5whiteE"]
    pub static vex_color_white: vex_color;
}
extern "C" {
    #[doc = "@brief Represents the color red."]
    #[link_name = "\u{1}_ZN3vex5color3redE"]
    pub static vex_color_red: vex_color;
}
extern "C" {
    #[doc = "@brief Represents the color green."]
    #[link_name = "\u{1}_ZN3vex5color5greenE"]
    pub static vex_color_green: vex_color;
}
extern "C" {
    #[doc = "@brief Represents the color blue."]
    #[link_name = "\u{1}_ZN3vex5color4blueE"]
    pub static vex_color_blue: vex_color;
}
extern "C" {
    #[doc = "@brief Represents the color yellow."]
    #[link_name = "\u{1}_ZN3vex5color6yellowE"]
    pub static vex_color_yellow: vex_color;
}
extern "C" {
    #[doc = "@brief Represents the color orange."]
    #[link_name = "\u{1}_ZN3vex5color6orangeE"]
    pub static vex_color_orange: vex_color;
}
extern "C" {
    #[doc = "@brief Represents the color purple."]
    #[link_name = "\u{1}_ZN3vex5color6purpleE"]
    pub static vex_color_purple: vex_color;
}
extern "C" {
    #[doc = "@brief Represents the color cyan."]
    #[link_name = "\u{1}_ZN3vex5color4cyanE"]
    pub static vex_color_cyan: vex_color;
}
extern "C" {
    #[doc = "@brief Represents the color transparent."]
    #[link_name = "\u{1}_ZN3vex5color11transparentE"]
    pub static vex_color_transparent: vex_color;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5color3rgbEj"]
    pub fn vex_color_rgb(this: *mut vex_color, value: u32) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5color3rgbEhhh"]
    pub fn vex_color_rgb1(this: *mut vex_color, r: u8, g: u8, b: u8) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3vex5color3rgbEv"]
    pub fn vex_color_rgb2(this: *const vex_color) -> u32;
}
extern "C" {
    #[doc = " @brief Gets the state of the color's transparency.\n @return Returns true if the color is transparent."]
    #[link_name = "\u{1}_ZNK3vex5color13isTransparentEv"]
    pub fn vex_color_isTransparent(this: *const vex_color) -> bool;
}
extern "C" {
    #[doc = " @brief Creates a color using hue, saturation, and brightness values.\n @return Returns a reference to a color.\n @param hue An integer from 0 to 360 that represents the hue of the color.\n @param sat A double from 0.0 to 1.0 that represents the saturation of the color.\n @param value A double from 0.0 to 1.0 that represents the brightness of the color."]
    #[link_name = "\u{1}_ZN3vex5color3hsvEjdd"]
    pub fn vex_color_hsv(this: *mut vex_color, hue: u32, sat: f64, value: f64) -> *mut vex_color;
}
extern "C" {
    #[doc = " @brief Creates a color using a hexadecimal value.\n @return Returns a reference to a color.\n @param color A hexadecimal or web color value that defines a specific color."]
    #[link_name = "\u{1}_ZN3vex5color3webEPKc"]
    pub fn vex_color_web(this: *mut vex_color, color: *const ::core::ffi::c_char)
        -> *mut vex_color;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5colorC1Ev"]
    pub fn vex_color_color(this: *mut vex_color);
}
extern "C" {
    #[doc = " @brief Creates a color.\n @param value The value of the color."]
    #[link_name = "\u{1}_ZN3vex5colorC1Ei"]
    pub fn vex_color_color1(this: *mut vex_color, value: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief Creates a color using red, green, and blue values.\n @param r the color of red on a scale of 0 to 255.\n @param g the color of green on a scale of 0 to 255.\n @param b the color of blue on a scale of 0 to 255."]
    #[link_name = "\u{1}_ZN3vex5colorC1Ehhh"]
    pub fn vex_color_color2(this: *mut vex_color, r: u8, g: u8, b: u8);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5colorD1Ev"]
    pub fn vex_color_color_destructor(this: *mut vex_color);
}
impl vex_color {
    #[inline]
    pub unsafe fn rgb(&mut self, value: u32) -> u32 {
        vex_color_rgb(self, value)
    }
    #[inline]
    pub unsafe fn rgb1(&mut self, r: u8, g: u8, b: u8) -> u32 {
        vex_color_rgb1(self, r, g, b)
    }
    #[inline]
    pub unsafe fn rgb2(&self) -> u32 {
        vex_color_rgb2(self)
    }
    #[inline]
    pub unsafe fn isTransparent(&self) -> bool {
        vex_color_isTransparent(self)
    }
    #[inline]
    pub unsafe fn hsv(&mut self, hue: u32, sat: f64, value: f64) -> *mut vex_color {
        vex_color_hsv(self, hue, sat, value)
    }
    #[inline]
    pub unsafe fn web(&mut self, color: *const ::core::ffi::c_char) -> *mut vex_color {
        vex_color_web(self, color)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_color_color(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(value: ::core::ffi::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_color_color1(__bindgen_tmp.as_mut_ptr(), value);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(r: u8, g: u8, b: u8) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_color_color2(__bindgen_tmp.as_mut_ptr(), r, g, b);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_color_color_destructor(self)
    }
}
#[doc = " @brief Use the timer class to create timers for your program."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_timer {
    pub _offset: u32,
    pub _initial: u32,
}
extern "C" {
    #[doc = " @brief Gets the current value of the timer in mS.\n @return Returns the current value of the timer in mS."]
    #[link_name = "\u{1}_ZNK3vex5timer4timeEv"]
    pub fn vex_timer_time(this: *const vex_timer) -> u32;
}
extern "C" {
    #[doc = " @brief Gets the current value of the timer in specified units.\n @return Returns a double that represents the time in the specified units.\n @param units The measurement unit for time."]
    #[link_name = "\u{1}_ZNK3vex5timer4timeENS_9timeUnitsE"]
    pub fn vex_timer_time1(this: *const vex_timer, units: vex_timeUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the current value of the timer in seconds.\n @return Returns the current value of the timer in seconds."]
    #[link_name = "\u{1}_ZNK3vex5timer5valueEv"]
    pub fn vex_timer_value(this: *const vex_timer) -> f64;
}
extern "C" {
    #[doc = " @brief Sets the current value of the timer to 0."]
    #[link_name = "\u{1}_ZN3vex5timer5clearEv"]
    pub fn vex_timer_clear(this: *mut vex_timer);
}
extern "C" {
    #[doc = " @brief Sets the current value of the timer to 0."]
    #[link_name = "\u{1}_ZN3vex5timer5resetEv"]
    pub fn vex_timer_reset(this: *mut vex_timer);
}
extern "C" {
    #[doc = " @brief Gets the current value of the system timer in mS.\n @return Returns the value of the system timer in mS."]
    #[link_name = "\u{1}_ZN3vex5timer6systemEv"]
    pub fn vex_timer_system() -> u32;
}
extern "C" {
    #[doc = " @brief Gets the current value of the high-resolution timer (in microseconds).\n @return Returns the current value of the high-resolution timer (in microseconds)."]
    #[link_name = "\u{1}_ZN3vex5timer20systemHighResolutionEv"]
    pub fn vex_timer_systemHighResolution() -> u64;
}
extern "C" {
    #[doc = " @brief Sets a callback that will be called in the future.\n @param callback A pointer to a function that will be called when the timer expires.\n @param value The delay in mS to when the function will be called."]
    #[link_name = "\u{1}_ZN3vex5timer5eventEPFvPvEj"]
    pub fn vex_timer_event(
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        value: u32,
    );
}
extern "C" {
    #[doc = " @brief Sets a callback that will be called in the future.\n @param callback A pointer to a function that will be called when the timer expires.\n @param value The delay in mS to when the function will be called."]
    #[link_name = "\u{1}_ZN3vex5timer5eventEPFvvEj"]
    pub fn vex_timer_event1(callback: ::core::option::Option<unsafe extern "C" fn()>, value: u32);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5timerC1Ev"]
    pub fn vex_timer_timer(this: *mut vex_timer);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5timerD1Ev"]
    pub fn vex_timer_timer_destructor(this: *mut vex_timer);
}
impl vex_timer {
    #[inline]
    pub unsafe fn time(&self) -> u32 {
        vex_timer_time(self)
    }
    #[inline]
    pub unsafe fn time1(&self, units: vex_timeUnits) -> f64 {
        vex_timer_time1(self, units)
    }
    #[inline]
    pub unsafe fn value(&self) -> f64 {
        vex_timer_value(self)
    }
    #[inline]
    pub unsafe fn clear(&mut self) {
        vex_timer_clear(self)
    }
    #[inline]
    pub unsafe fn reset(&mut self) {
        vex_timer_reset(self)
    }
    #[inline]
    pub unsafe fn system() -> u32 {
        vex_timer_system()
    }
    #[inline]
    pub unsafe fn systemHighResolution() -> u64 {
        vex_timer_systemHighResolution()
    }
    #[inline]
    pub unsafe fn event(
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        value: u32,
    ) {
        vex_timer_event(callback, value)
    }
    #[inline]
    pub unsafe fn event1(callback: ::core::option::Option<unsafe extern "C" fn()>, value: u32) {
        vex_timer_event1(callback, value)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_timer_timer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_timer_timer_destructor(self)
    }
}
#[repr(C)]
pub struct vex_device__bindgen_vtable(::core::ffi::c_void);
#[doc = " @brief Use the device class to get information about a vex device plugged into the V5."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_device {
    pub vtable_: *const vex_device__bindgen_vtable,
    pub _ptr: V5_DeviceT,
    pub _index: i32,
    pub _threadID: i32,
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6device5flagsEv"]
    pub fn vex_device_flags(this: *mut vex_device) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6device4typeEv"]
    pub fn vex_device_type(this: *mut vex_device) -> V5_DeviceType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6device5indexEv"]
    pub fn vex_device_index(this: *mut vex_device) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6device4initEi"]
    pub fn vex_device_init(this: *mut vex_device, index: i32);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6device9timestampEv"]
    pub fn vex_device_timestamp(this: *mut vex_device) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6deviceC1Ev"]
    pub fn vex_device_device(this: *mut vex_device);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6deviceC1Ei"]
    pub fn vex_device_device1(this: *mut vex_device, index: i32);
}
impl vex_device {
    #[inline]
    pub unsafe fn flags(&mut self) -> i32 {
        vex_device_flags(self)
    }
    #[inline]
    pub unsafe fn type_(&mut self) -> V5_DeviceType {
        vex_device_type(self)
    }
    #[inline]
    pub unsafe fn index(&mut self) -> i32 {
        vex_device_index(self)
    }
    #[inline]
    pub unsafe fn init(&mut self, index: i32) {
        vex_device_init(self, index)
    }
    #[inline]
    pub unsafe fn timestamp(&mut self) -> u32 {
        vex_device_timestamp(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_device_device(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(index: i32) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_device_device1(__bindgen_tmp.as_mut_ptr(), index);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6deviceD1Ev"]
    pub fn vex_device_device_destructor(this: *mut vex_device);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6device9installedEv"]
    pub fn vex_device_installed(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6device5valueEv"]
    pub fn vex_device_value(this: *mut ::core::ffi::c_void) -> i32;
}
#[repr(C)]
pub struct vex_guido__bindgen_vtable(::core::ffi::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct vex_guido {
    pub vtable_: *const vex_guido__bindgen_vtable,
}
#[doc = " @brief Use the device class to get information about all of the vex devices plugged into the V5."]
#[repr(C)]
pub struct vex_devices {
    pub data: [u32; 133usize],
}
extern "C" {
    #[doc = " @brief Get the V5 device type plugged into a specific port.\n @return Returns a V5 device type.\n @param index Specifies the index to look at for the device."]
    #[link_name = "\u{1}_ZN3vex7devices4typeEi"]
    pub fn vex_devices_type(this: *mut vex_devices, index: i32) -> V5_DeviceType;
}
extern "C" {
    #[doc = " @brief Gets the number of VEX devices that are plugged in.\n @return Returns an integer that represent the number of vex devices"]
    #[link_name = "\u{1}_ZN3vex7devices6numberEv"]
    pub fn vex_devices_number(this: *mut vex_devices) -> i32;
}
extern "C" {
    #[doc = " @brief Gets the number of specified devices that are plugged into the V5.\n @return Returns an integer that represents the number of a specific vex devices set by the parameter.\n @param  type The type of device to look for on the V5."]
    #[link_name = "\u{1}_ZN3vex7devices8numberOfE13V5_DeviceType"]
    pub fn vex_devices_numberOf(this: *mut vex_devices, type_: V5_DeviceType) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7devicesC1Ev"]
    pub fn vex_devices_devices(this: *mut vex_devices);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7devicesD1Ev"]
    pub fn vex_devices_devices_destructor(this: *mut vex_devices);
}
impl vex_devices {
    #[inline]
    pub unsafe fn type_(&mut self, index: i32) -> V5_DeviceType {
        vex_devices_type(self, index)
    }
    #[inline]
    pub unsafe fn number(&mut self) -> i32 {
        vex_devices_number(self)
    }
    #[inline]
    pub unsafe fn numberOf(&mut self, type_: V5_DeviceType) -> i32 {
        vex_devices_numberOf(self, type_)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_devices_devices(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_devices_devices_destructor(self)
    }
}
#[doc = " @brief Use this class to get and set information about devices on Three Wire Ports A through H."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_triport {
    pub _base: vex_device,
    pub _id: u32,
    pub Port: [vex_triport_port; 8usize],
    #[doc = " @brief A Three Wire Port that is labeled as A on the Brain."]
    pub A: *mut vex_triport_port,
    #[doc = " @brief A Three Wire Port that is labeled as B on the Brain."]
    pub B: *mut vex_triport_port,
    #[doc = " @brief A Three Wire Port that is labeled as C on the Brain."]
    pub C: *mut vex_triport_port,
    #[doc = " @brief A Three Wire Port that is labeled as D on the Brain."]
    pub D: *mut vex_triport_port,
    #[doc = " @brief A Three Wire Port that is labeled as E on the Brain."]
    pub E: *mut vex_triport_port,
    #[doc = " @brief A Three Wire Port that is labeled as F on the Brain."]
    pub F: *mut vex_triport_port,
    #[doc = " @brief A Three Wire Port that is labeled as G on the Brain."]
    pub G: *mut vex_triport_port,
    #[doc = " @brief A Three Wire Port that is labeled as H on the Brain."]
    pub H: *mut vex_triport_port,
}
pub const vex_triport_tEventType_EVENT_DIN_HIGH: vex_triport_tEventType = 0;
pub const vex_triport_tEventType_EVENT_DIN_LOW: vex_triport_tEventType = 1;
pub const vex_triport_tEventType_EVENT_AIN_CHANGED: vex_triport_tEventType = 2;
pub type vex_triport_tEventType = ::core::ffi::c_int;
#[doc = " @brief TBD"]
#[repr(C)]
#[derive(Debug)]
pub struct vex_triport_port {
    pub _id: i32,
    pub _parent: *mut vex_triport,
    pub PRESSED: vex_mevent,
    pub RELEASED: vex_mevent,
    pub CHANGED: vex_mevent,
    pub HIGH: *mut vex_mevent,
    pub LOW: *mut vex_mevent,
}
extern "C" {
    #[doc = " @brief Sets the port to a specific port type.\n @param type A type of port that you want to set it to."]
    #[link_name = "\u{1}_ZN3vex7triport4port4typeENS_11triportTypeE"]
    pub fn vex_triport_port_type(this: *mut vex_triport_port, type_: vex_triportType);
}
extern "C" {
    #[doc = " @brief Gets the current port type.\n @return Returns the Port Type."]
    #[link_name = "\u{1}_ZN3vex7triport4port4typeEv"]
    pub fn vex_triport_port_type1(this: *mut vex_triport_port) -> vex_triportType;
}
extern "C" {
    #[doc = " @brief Gets the index of the parent smart port"]
    #[link_name = "\u{1}_ZN3vex7triport4port5indexEv"]
    pub fn vex_triport_port_index(this: *mut vex_triport_port) -> i32;
}
extern "C" {
    #[doc = " @brief Gets the id of the port\n @return Returns an integer in the range 0 to 7, -1 for error"]
    #[link_name = "\u{1}_ZN3vex7triport4port2idEv"]
    pub fn vex_triport_port_id(this: *mut vex_triport_port) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the port's value to the specified integer in the parameter.\n @param value An integer number that will be set to the port's value."]
    #[link_name = "\u{1}_ZN3vex7triport4port5valueEi"]
    pub fn vex_triport_port_value(this: *mut vex_triport_port, value: i32);
}
extern "C" {
    #[doc = " @brief Gets the value of a port.\n @return Returns an integer that represents the port's value."]
    #[link_name = "\u{1}_ZN3vex7triport4port5valueEv"]
    pub fn vex_triport_port_value1(this: *mut vex_triport_port) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the value of the port to a Boolean value.\n @param value A true or false Boolean value that the port will be set to."]
    #[link_name = "\u{1}_ZN3vex7triport4port3setEb"]
    pub fn vex_triport_port_set(this: *mut vex_triport_port, value: bool);
}
extern "C" {
    #[doc = " @brief Calls back a function when the port is pressed.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex7triport4port7pressedEPFvvE"]
    pub fn vex_triport_port_pressed(
        this: *mut vex_triport_port,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Calls back a function when the port is released.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex7triport4port8releasedEPFvvE"]
    pub fn vex_triport_port_released(
        this: *mut vex_triport_port,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Calls back a function when the port has changed value.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex7triport4port7changedEPFvvE"]
    pub fn vex_triport_port_changed(
        this: *mut vex_triport_port,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Resets the rotation of the encoder to zero."]
    #[link_name = "\u{1}_ZN3vex7triport4port13resetRotationEv"]
    pub fn vex_triport_port_resetRotation(this: *mut vex_triport_port);
}
extern "C" {
    #[doc = " @brief Sets the rotation of the encoder to a specific value.\n @param val A double that represents the value to set the rotation to.\n @param units The unit type that the previous value should be treated as."]
    #[link_name = "\u{1}_ZN3vex7triport4port11setRotationEdNS_13rotationUnitsE"]
    pub fn vex_triport_port_setRotation(
        this: *mut vex_triport_port,
        val: f64,
        units: vex_rotationUnits,
    );
}
extern "C" {
    #[doc = " @brief Gets the rotation value of the encoder.\n @return Returns a double that represents the current rotation of the encoder.\n @param units A unit type that defines what value of rotation that should be returned."]
    #[link_name = "\u{1}_ZN3vex7triport4port8rotationENS_13rotationUnitsE"]
    pub fn vex_triport_port_rotation(this: *mut vex_triport_port, units: vex_rotationUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the velocity of the encoder.\n @return Returns a double that represents the current velocity of the encoder.\n @param units A unit type that defines what value of velocity that should be returned."]
    #[link_name = "\u{1}_ZN3vex7triport4port8velocityENS_13velocityUnitsE"]
    pub fn vex_triport_port_velocity(this: *mut vex_triport_port, units: vex_velocityUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the value of the distance sensor.\n @return Returns a double that represents the current distance of the sensor.\n @param units A distance unit type that defines what value of distance that should be returned."]
    #[link_name = "\u{1}_ZN3vex7triport4port8distanceENS_13distanceUnitsE"]
    pub fn vex_triport_port_distance(this: *mut vex_triport_port, units: vex_distanceUnits) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7triport4portC1EiPS0_"]
    pub fn vex_triport_port_port(this: *mut vex_triport_port, id: i32, parent: *mut vex_triport);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7triport4portC1EiNS_11triportTypeEPS0_"]
    pub fn vex_triport_port_port1(
        this: *mut vex_triport_port,
        id: i32,
        type_: vex_triportType,
        parent: *mut vex_triport,
    );
}
impl vex_triport_port {
    #[inline]
    pub unsafe fn type_(&mut self, type_: vex_triportType) {
        vex_triport_port_type(self, type_)
    }
    #[inline]
    pub unsafe fn type1(&mut self) -> vex_triportType {
        vex_triport_port_type1(self)
    }
    #[inline]
    pub unsafe fn index(&mut self) -> i32 {
        vex_triport_port_index(self)
    }
    #[inline]
    pub unsafe fn id(&mut self) -> i32 {
        vex_triport_port_id(self)
    }
    #[inline]
    pub unsafe fn value(&mut self, value: i32) {
        vex_triport_port_value(self, value)
    }
    #[inline]
    pub unsafe fn value1(&mut self) -> i32 {
        vex_triport_port_value1(self)
    }
    #[inline]
    pub unsafe fn set(&mut self, value: bool) {
        vex_triport_port_set(self, value)
    }
    #[inline]
    pub unsafe fn pressed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_triport_port_pressed(self, callback)
    }
    #[inline]
    pub unsafe fn released(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_triport_port_released(self, callback)
    }
    #[inline]
    pub unsafe fn changed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_triport_port_changed(self, callback)
    }
    #[inline]
    pub unsafe fn resetRotation(&mut self) {
        vex_triport_port_resetRotation(self)
    }
    #[inline]
    pub unsafe fn setRotation(&mut self, val: f64, units: vex_rotationUnits) {
        vex_triport_port_setRotation(self, val, units)
    }
    #[inline]
    pub unsafe fn rotation(&mut self, units: vex_rotationUnits) -> f64 {
        vex_triport_port_rotation(self, units)
    }
    #[inline]
    pub unsafe fn velocity(&mut self, units: vex_velocityUnits) -> f64 {
        vex_triport_port_velocity(self, units)
    }
    #[inline]
    pub unsafe fn distance(&mut self, units: vex_distanceUnits) -> f64 {
        vex_triport_port_distance(self, units)
    }
    #[inline]
    pub unsafe fn new(id: i32, parent: *mut vex_triport) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_triport_port_port(__bindgen_tmp.as_mut_ptr(), id, parent);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(id: i32, type_: vex_triportType, parent: *mut vex_triport) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_triport_port_port1(__bindgen_tmp.as_mut_ptr(), id, type_, parent);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7triportC1Ei"]
    pub fn vex_triport_triport(this: *mut vex_triport, index: i32);
}
impl vex_triport {
    #[inline]
    pub unsafe fn new(index: i32) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_triport_triport(__bindgen_tmp.as_mut_ptr(), index);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7triportD1Ev"]
    pub fn vex_triport_triport_destructor(this: *mut vex_triport);
}
extern "C" {
    #[doc = " @brief Gets the status of what is installed on the port.\n @return Returns true if a 3-Wire Port device is installed in the port, otherwise false."]
    #[link_name = "\u{1}_ZN3vex7triport9installedEv"]
    pub fn vex_triport_installed(this: *mut ::core::ffi::c_void) -> bool;
}
#[doc = " @brief Base class that allows access to Three Wire Port functions and members."]
#[repr(C)]
#[derive(Debug)]
pub struct vex___tridevice {
    pub _port: *mut vex_triport_port,
    pub _PRESSED: *mut vex_mevent,
    pub _RELEASED: *mut vex_mevent,
    pub _CHANGED: *mut vex_mevent,
    pub _HIGH: *mut vex_mevent,
    pub _LOW: *mut vex_mevent,
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11__tridevice14_convertAnalogENS_11analogUnitsE"]
    pub fn vex___tridevice__convertAnalog(
        this: *mut vex___tridevice,
        units: vex_analogUnits,
    ) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11__tridevice14_virtual_valueEi"]
    pub fn vex___tridevice__virtual_value(this: *mut vex___tridevice, virtual_port: i32) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11__tridevice6_indexEv"]
    pub fn vex___tridevice__index(this: *mut vex___tridevice) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11__tridevice3_idEv"]
    pub fn vex___tridevice__id(this: *mut vex___tridevice) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11__trideviceC1ERNS_7triport4portENS_11triportTypeE"]
    pub fn vex___tridevice___tridevice(
        this: *mut vex___tridevice,
        port: *mut vex_triport_port,
        type_: vex_triportType,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11__trideviceD1Ev"]
    pub fn vex___tridevice___tridevice_destructor(this: *mut vex___tridevice);
}
impl vex___tridevice {
    #[inline]
    pub unsafe fn _convertAnalog(&mut self, units: vex_analogUnits) -> i32 {
        vex___tridevice__convertAnalog(self, units)
    }
    #[inline]
    pub unsafe fn _virtual_value(&mut self, virtual_port: i32) -> i32 {
        vex___tridevice__virtual_value(self, virtual_port)
    }
    #[inline]
    pub unsafe fn _index(&mut self) -> i32 {
        vex___tridevice__index(self)
    }
    #[inline]
    pub unsafe fn _id(&mut self) -> i32 {
        vex___tridevice__id(self)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port, type_: vex_triportType) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex___tridevice___tridevice(__bindgen_tmp.as_mut_ptr(), port, type_);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex___tridevice___tridevice_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with the limit switch"]
#[repr(C)]
#[derive(Debug)]
pub struct vex_limit {
    pub _base: vex___tridevice,
    pub PRESSED: *mut vex_mevent,
    pub RELEASED: *mut vex_mevent,
}
extern "C" {
    #[doc = " @brief Gets the value of the limit switch\n @return Returns an integer that represents the value of the limit switch."]
    #[link_name = "\u{1}_ZN3vex5limit5valueEv"]
    pub fn vex_limit_value(this: *mut vex_limit) -> i32;
}
extern "C" {
    #[doc = " @brief Calls a function when the limit switch is pressed.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex5limit7pressedEPFvvE"]
    pub fn vex_limit_pressed(
        this: *mut vex_limit,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Calls a function when the limit switch is released.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex5limit8releasedEPFvvE"]
    pub fn vex_limit_released(
        this: *mut vex_limit,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Creates a new limit object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex5limitC1ERNS_7triport4portE"]
    pub fn vex_limit_limit(this: *mut vex_limit, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5limitD1Ev"]
    pub fn vex_limit_limit_destructor(this: *mut vex_limit);
}
impl vex_limit {
    #[inline]
    pub unsafe fn value(&mut self) -> i32 {
        vex_limit_value(self)
    }
    #[inline]
    pub unsafe fn pressed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_limit_pressed(self, callback)
    }
    #[inline]
    pub unsafe fn released(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_limit_released(self, callback)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_limit_limit(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_limit_limit_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with the bumper device"]
#[repr(C)]
#[derive(Debug)]
pub struct vex_bumper {
    pub _base: vex___tridevice,
    pub PRESSED: *mut vex_mevent,
    pub RELEASED: *mut vex_mevent,
}
extern "C" {
    #[doc = " @brief Gets the value of the bumper switch.\n @return Returns an integer that represents the value of the bumper switch."]
    #[link_name = "\u{1}_ZN3vex6bumper5valueEv"]
    pub fn vex_bumper_value(this: *mut vex_bumper) -> i32;
}
extern "C" {
    #[doc = " @brief Calls a function when the bumper switch is pressed.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex6bumper7pressedEPFvvE"]
    pub fn vex_bumper_pressed(
        this: *mut vex_bumper,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Calls a function when the bumper switch is released.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex6bumper8releasedEPFvvE"]
    pub fn vex_bumper_released(
        this: *mut vex_bumper,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Creates a new bumper switch object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex6bumperC1ERNS_7triport4portE"]
    pub fn vex_bumper_bumper(this: *mut vex_bumper, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6bumperD1Ev"]
    pub fn vex_bumper_bumper_destructor(this: *mut vex_bumper);
}
impl vex_bumper {
    #[inline]
    pub unsafe fn value(&mut self) -> i32 {
        vex_bumper_value(self)
    }
    #[inline]
    pub unsafe fn pressed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_bumper_pressed(self, callback)
    }
    #[inline]
    pub unsafe fn released(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_bumper_released(self, callback)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_bumper_bumper(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_bumper_bumper_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a digital-in device"]
#[repr(C)]
#[derive(Debug)]
pub struct vex_digital_in {
    pub _base: vex___tridevice,
    pub HIGH: *mut vex_mevent,
    pub LOW: *mut vex_mevent,
}
extern "C" {
    #[doc = " @brief Gets the value of the digital_in device.\n @return Returns an integer that represents the value of the digital-in device."]
    #[link_name = "\u{1}_ZN3vex10digital_in5valueEv"]
    pub fn vex_digital_in_value(this: *mut vex_digital_in) -> i32;
}
extern "C" {
    #[doc = " @brief Calls a function when the digital input goes high.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex10digital_in4highEPFvvE"]
    pub fn vex_digital_in_high(
        this: *mut vex_digital_in,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Calls a function when the digital input goes low.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex10digital_in3lowEPFvvE"]
    pub fn vex_digital_in_low(
        this: *mut vex_digital_in,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Creates a new digital_in object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex10digital_inC1ERNS_7triport4portE"]
    pub fn vex_digital_in_digital_in(this: *mut vex_digital_in, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex10digital_inD1Ev"]
    pub fn vex_digital_in_digital_in_destructor(this: *mut vex_digital_in);
}
impl vex_digital_in {
    #[inline]
    pub unsafe fn value(&mut self) -> i32 {
        vex_digital_in_value(self)
    }
    #[inline]
    pub unsafe fn high(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_digital_in_high(self, callback)
    }
    #[inline]
    pub unsafe fn low(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_digital_in_low(self, callback)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_digital_in_digital_in(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_digital_in_digital_in_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a digital-out device."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_digital_out {
    pub _base: vex___tridevice,
}
extern "C" {
    #[doc = " @brief Gets the value of the digital_out device.\n @return Returns an integer that represents the value of the digital-out device."]
    #[link_name = "\u{1}_ZN3vex11digital_out5valueEv"]
    pub fn vex_digital_out_value(this: *mut vex_digital_out) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the digital_out device to a Boolean value.\n @param value A true or false Boolean value."]
    #[link_name = "\u{1}_ZN3vex11digital_out3setEb"]
    pub fn vex_digital_out_set(this: *mut vex_digital_out, value: bool);
}
extern "C" {
    #[doc = " @brief Creates a new digital_out object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex11digital_outC1ERNS_7triport4portE"]
    pub fn vex_digital_out_digital_out(this: *mut vex_digital_out, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11digital_outD1Ev"]
    pub fn vex_digital_out_digital_out_destructor(this: *mut vex_digital_out);
}
impl vex_digital_out {
    #[inline]
    pub unsafe fn value(&mut self) -> i32 {
        vex_digital_out_value(self)
    }
    #[inline]
    pub unsafe fn set(&mut self, value: bool) {
        vex_digital_out_set(self, value)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_digital_out_digital_out(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_digital_out_digital_out_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a led device."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_led {
    pub _base: vex_digital_out,
}
extern "C" {
    #[doc = " @brief Sets the led device to the on state."]
    #[link_name = "\u{1}_ZN3vex3led2onEv"]
    pub fn vex_led_on(this: *mut vex_led);
}
extern "C" {
    #[doc = " @brief Sets the led device to the off state."]
    #[link_name = "\u{1}_ZN3vex3led3offEv"]
    pub fn vex_led_off(this: *mut vex_led);
}
extern "C" {
    #[doc = " @brief Creates a new led object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex3ledC1ERNS_7triport4portE"]
    pub fn vex_led_led(this: *mut vex_led, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex3ledD1Ev"]
    pub fn vex_led_led_destructor(this: *mut vex_led);
}
impl vex_led {
    #[inline]
    pub unsafe fn on(&mut self) {
        vex_led_on(self)
    }
    #[inline]
    pub unsafe fn off(&mut self) {
        vex_led_off(self)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_led_led(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_led_led_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a pneumatics device."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_pneumatics {
    pub _base: vex_digital_out,
}
extern "C" {
    #[doc = " @brief Sets the pneumatics device to the solenoid open state allowing air to flow into the cylinder."]
    #[link_name = "\u{1}_ZN3vex10pneumatics4openEv"]
    pub fn vex_pneumatics_open(this: *mut vex_pneumatics);
}
extern "C" {
    #[doc = " @brief Sets the pneumatics device to the solenoid close state stopping air flowing into the cylinder."]
    #[link_name = "\u{1}_ZN3vex10pneumatics5closeEv"]
    pub fn vex_pneumatics_close(this: *mut vex_pneumatics);
}
extern "C" {
    #[doc = " @brief Creates a new pneumatics object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex10pneumaticsC1ERNS_7triport4portE"]
    pub fn vex_pneumatics_pneumatics(this: *mut vex_pneumatics, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex10pneumaticsD1Ev"]
    pub fn vex_pneumatics_pneumatics_destructor(this: *mut vex_pneumatics);
}
impl vex_pneumatics {
    #[inline]
    pub unsafe fn open(&mut self) {
        vex_pneumatics_open(self)
    }
    #[inline]
    pub unsafe fn close(&mut self) {
        vex_pneumatics_close(self)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_pneumatics_pneumatics(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_pneumatics_pneumatics_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a potentiometer."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_pot {
    pub _base: vex___tridevice,
    pub CHANGED: *mut vex_mevent,
}
extern "C" {
    #[doc = " @brief Gets the value of the potentiometer in the units defined in the parameter.\n @return Returns an integer that represents the unit value specified by the parameter of the potentiometer device.\n @param units The measurement unit for the potentiometer device."]
    #[link_name = "\u{1}_ZN3vex3pot5valueENS_11analogUnitsE"]
    pub fn vex_pot_value(this: *mut vex_pot, units: vex_analogUnits) -> i32;
}
extern "C" {
    #[doc = " @brief Gets the value of the potentiometer in the units defined in the parameter.\n @return Returns an integer that represents the unit value specified by the parameter of the potentiometer device.\n @param units The measurement unit for the potentiometer device."]
    #[link_name = "\u{1}_ZN3vex3pot5valueENS_13rotationUnitsE"]
    pub fn vex_pot_value1(this: *mut vex_pot, units: vex_rotationUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Calls a function when the potentiometer value changes.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex3pot7changedEPFvvE"]
    pub fn vex_pot_changed(
        this: *mut vex_pot,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Creates a new pot object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex3potC1ERNS_7triport4portE"]
    pub fn vex_pot_pot(this: *mut vex_pot, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex3potD1Ev"]
    pub fn vex_pot_pot_destructor(this: *mut vex_pot);
}
impl vex_pot {
    #[inline]
    pub unsafe fn value(&mut self, units: vex_analogUnits) -> i32 {
        vex_pot_value(self, units)
    }
    #[inline]
    pub unsafe fn value1(&mut self, units: vex_rotationUnits) -> f64 {
        vex_pot_value1(self, units)
    }
    #[inline]
    pub unsafe fn changed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_pot_changed(self, callback)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_pot_pot(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_pot_pot_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a continuous rotation potentiometer."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_potV2 {
    pub _base: vex___tridevice,
    pub CHANGED: *mut vex_mevent,
}
extern "C" {
    #[doc = " @brief Gets the value of the potentiometer in the units defined in the parameter.\n @return Returns an integer that represents the unit value specified by the parameter of the potentiometer device.\n @param units The measurement unit for the potentiometer device."]
    #[link_name = "\u{1}_ZN3vex5potV25valueENS_11analogUnitsE"]
    pub fn vex_potV2_value(this: *mut vex_potV2, units: vex_analogUnits) -> i32;
}
extern "C" {
    #[doc = " @brief Gets the value of the potentiometer in the units defined in the parameter.\n @return Returns an integer that represents the unit value specified by the parameter of the potentiometer device.\n @param units The measurement unit for the potentiometer device."]
    #[link_name = "\u{1}_ZN3vex5potV25valueENS_13rotationUnitsE"]
    pub fn vex_potV2_value1(this: *mut vex_potV2, units: vex_rotationUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Calls a function when the potentiometer value changes.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex5potV27changedEPFvvE"]
    pub fn vex_potV2_changed(
        this: *mut vex_potV2,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Creates a new pot object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex5potV2C1ERNS_7triport4portE"]
    pub fn vex_potV2_potV2(this: *mut vex_potV2, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5potV2D1Ev"]
    pub fn vex_potV2_potV2_destructor(this: *mut vex_potV2);
}
impl vex_potV2 {
    #[inline]
    pub unsafe fn value(&mut self, units: vex_analogUnits) -> i32 {
        vex_potV2_value(self, units)
    }
    #[inline]
    pub unsafe fn value1(&mut self, units: vex_rotationUnits) -> f64 {
        vex_potV2_value1(self, units)
    }
    #[inline]
    pub unsafe fn changed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_potV2_changed(self, callback)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_potV2_potV2(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_potV2_potV2_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a line follower."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_line {
    pub _base: vex___tridevice,
    pub CHANGED: *mut vex_mevent,
}
extern "C" {
    #[doc = " @brief Gets the value of the line follower.\n @return Returns an integer that represents the unit value specified by the parameter of the line follower.\n @param units The measurement unit for the line device."]
    #[link_name = "\u{1}_ZN3vex4line5valueENS_11analogUnitsE"]
    pub fn vex_line_value(this: *mut vex_line, units: vex_analogUnits) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4line12reflectivityENS_12percentUnitsE"]
    pub fn vex_line_reflectivity(this: *mut vex_line, units: vex_percentUnits) -> i32;
}
extern "C" {
    #[doc = " @brief Calls a function when the line sensor value changes.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex4line7changedEPFvvE"]
    pub fn vex_line_changed(
        this: *mut vex_line,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Creates a new line object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex4lineC1ERNS_7triport4portE"]
    pub fn vex_line_line(this: *mut vex_line, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4lineD1Ev"]
    pub fn vex_line_line_destructor(this: *mut vex_line);
}
impl vex_line {
    #[inline]
    pub unsafe fn value(&mut self, units: vex_analogUnits) -> i32 {
        vex_line_value(self, units)
    }
    #[inline]
    pub unsafe fn reflectivity(&mut self, units: vex_percentUnits) -> i32 {
        vex_line_reflectivity(self, units)
    }
    #[inline]
    pub unsafe fn changed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_line_changed(self, callback)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_line_line(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_line_line_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a light sensor."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_light {
    pub _base: vex___tridevice,
    pub CHANGED: *mut vex_mevent,
}
extern "C" {
    #[doc = " @brief Gets the value of the light sensor.\n @return Returns an integer that represents the unit value specified by the parameter of the light sensor.\n @param units The measurement unit for the light device."]
    #[link_name = "\u{1}_ZN3vex5light5valueENS_11analogUnitsE"]
    pub fn vex_light_value(this: *mut vex_light, units: vex_analogUnits) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5light10brightnessENS_12percentUnitsE"]
    pub fn vex_light_brightness(this: *mut vex_light, units: vex_percentUnits) -> i32;
}
extern "C" {
    #[doc = " @brief Calls a function when the light sensor value changes.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex5light7changedEPFvvE"]
    pub fn vex_light_changed(
        this: *mut vex_light,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Creates a new light object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex5lightC1ERNS_7triport4portE"]
    pub fn vex_light_light(this: *mut vex_light, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5lightD1Ev"]
    pub fn vex_light_light_destructor(this: *mut vex_light);
}
impl vex_light {
    #[inline]
    pub unsafe fn value(&mut self, units: vex_analogUnits) -> i32 {
        vex_light_value(self, units)
    }
    #[inline]
    pub unsafe fn brightness(&mut self, units: vex_percentUnits) -> i32 {
        vex_light_brightness(self, units)
    }
    #[inline]
    pub unsafe fn changed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_light_changed(self, callback)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_light_light(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_light_light_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a gyro sensor."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_gyro {
    pub _base: vex___tridevice,
    pub _base_1: vex_guido,
    pub _offset_h: i32,
    pub _offset_r: i32,
    pub _cal_delay: u32,
    pub CHANGED: *mut vex_mevent,
}
extern "C" {
    #[doc = " @brief Gets the value of the gyro sensor.\n @return Returns an integer that represents the unit value specified by the parameter of the gyro sensor.\n @param units The measurement unit for the gyro device."]
    #[link_name = "\u{1}_ZN3vex4gyro5valueENS_11analogUnitsE"]
    pub fn vex_gyro_value(this: *mut vex_gyro, units: vex_analogUnits) -> i32;
}
extern "C" {
    #[doc = " @brief Gets the value of the gyro sensor.\n @return Returns an integer that represents the unit value specified by the parameter of the gyro sensor.\n @param units The measurement unit for the gyro device."]
    #[link_name = "\u{1}_ZN3vex4gyro5valueENS_13rotationUnitsE"]
    pub fn vex_gyro_value1(this: *mut vex_gyro, units: vex_rotationUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Starts recalibration of the gyro.\n @param value (Optional) Sets the amount of calibration time. By default, this parameter is zero."]
    #[link_name = "\u{1}_ZN3vex4gyro16startCalibrationEi"]
    pub fn vex_gyro_startCalibration(this: *mut vex_gyro, value: i32);
}
extern "C" {
    #[doc = " @brief Calls a function when the gyro sensor value changes.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex4gyro7changedEPFvvE"]
    pub fn vex_gyro_changed(
        this: *mut vex_gyro,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief reset the gyro sensor angle to 0"]
    #[link_name = "\u{1}_ZN3vex4gyro10resetAngleEv"]
    pub fn vex_gyro_resetAngle(this: *mut vex_gyro);
}
extern "C" {
    #[doc = " @brief reset the gyro sensor angle to 0"]
    #[link_name = "\u{1}_ZN3vex4gyro12resetHeadingEv"]
    pub fn vex_gyro_resetHeading(this: *mut vex_gyro);
}
extern "C" {
    #[doc = " @brief reset the gyro sensor absolute angle to 0"]
    #[link_name = "\u{1}_ZN3vex4gyro13resetRotationEv"]
    pub fn vex_gyro_resetRotation(this: *mut vex_gyro);
}
extern "C" {
    #[doc = " @brief reset the gyro sensor angle to angle\n @param value The new angle for the gyro\n @param units The rotation unit for the angle"]
    #[link_name = "\u{1}_ZN3vex4gyro10resetAngleEdNS_13rotationUnitsE"]
    pub fn vex_gyro_resetAngle1(this: *mut vex_gyro, value: f64, units: vex_rotationUnits);
}
extern "C" {
    #[doc = " @brief Creates a new gyro object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex4gyroC1ERNS_7triport4portE"]
    pub fn vex_gyro_gyro(this: *mut vex_gyro, port: *mut vex_triport_port);
}
impl vex_gyro {
    #[inline]
    pub unsafe fn value(&mut self, units: vex_analogUnits) -> i32 {
        vex_gyro_value(self, units)
    }
    #[inline]
    pub unsafe fn value1(&mut self, units: vex_rotationUnits) -> f64 {
        vex_gyro_value1(self, units)
    }
    #[inline]
    pub unsafe fn startCalibration(&mut self, value: i32) {
        vex_gyro_startCalibration(self, value)
    }
    #[inline]
    pub unsafe fn changed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_gyro_changed(self, callback)
    }
    #[inline]
    pub unsafe fn resetAngle(&mut self) {
        vex_gyro_resetAngle(self)
    }
    #[inline]
    pub unsafe fn resetHeading(&mut self) {
        vex_gyro_resetHeading(self)
    }
    #[inline]
    pub unsafe fn resetRotation(&mut self) {
        vex_gyro_resetRotation(self)
    }
    #[inline]
    pub unsafe fn resetAngle1(&mut self, value: f64, units: vex_rotationUnits) {
        vex_gyro_resetAngle1(self, value, units)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_gyro_gyro(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4gyroD1Ev"]
    pub fn vex_gyro_gyro_destructor(this: *mut vex_gyro);
}
extern "C" {
    #[doc = " @brief Returns true while the gyro sensor is performing a requested recalibration, changing to false once recalibration has completed.\n @return Returns true if gyro is still calibrating."]
    #[link_name = "\u{1}_ZN3vex4gyro13isCalibratingEv"]
    pub fn vex_gyro_isCalibrating(this: *mut ::core::ffi::c_void) -> bool;
}
extern "C" {
    #[doc = " @brief reset the gyro sensor angle to angle\n @param value The new heading for the gyro\n @param units The rotation unit for the angle"]
    #[link_name = "\u{1}_ZN3vex4gyro10setHeadingEdNS_13rotationUnitsE"]
    pub fn vex_gyro_setHeading(
        this: *mut ::core::ffi::c_void,
        value: f64,
        units: vex_rotationUnits,
    );
}
extern "C" {
    #[doc = " @brief Gets the angle of the gyro sensor.\n @return Returns a double that represents the unit value specified by the parameter of the gyro sensor.\n @param units The measurement unit for the gyro device."]
    #[link_name = "\u{1}_ZN3vex4gyro5angleENS_13rotationUnitsE"]
    pub fn vex_gyro_angle(this: *mut ::core::ffi::c_void, units: vex_rotationUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the angle of the gyro sensor.\n @return Returns a double that represents the unit value specified by the parameter of the gyro sensor.\n @param units The measurement unit for the gyro device."]
    #[link_name = "\u{1}_ZN3vex4gyro7headingENS_13rotationUnitsE"]
    pub fn vex_gyro_heading(this: *mut ::core::ffi::c_void, units: vex_rotationUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the rotation (absolute angle) of the gyro sensor.\n @return Returns a double that represents the unit value specified by the parameter of the gyro sensor.\n @param units The measurement unit for the gyro device."]
    #[link_name = "\u{1}_ZN3vex4gyro8rotationENS_13rotationUnitsE"]
    pub fn vex_gyro_rotation(this: *mut ::core::ffi::c_void, units: vex_rotationUnits) -> f64;
}
extern "C" {
    #[doc = " @brief set the gyro sensor rotation to angle\n @param value The new absolute angle for the gyro\n @param units The rotation unit for the angle"]
    #[link_name = "\u{1}_ZN3vex4gyro11setRotationEdNS_13rotationUnitsE"]
    pub fn vex_gyro_setRotation(
        this: *mut ::core::ffi::c_void,
        value: f64,
        units: vex_rotationUnits,
    );
}
extern "C" {
    #[doc = " @brief Get direction for positive angles\n @return turnType::right or turnType::left"]
    #[link_name = "\u{1}_ZN3vex4gyro11getTurnTypeEv"]
    pub fn vex_gyro_getTurnType(this: *mut ::core::ffi::c_void) -> vex_turnType;
}
#[doc = " @brief Use this class when programming with an accelerometer sensor."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_accelerometer {
    pub _base: vex___tridevice,
    pub CHANGED: *mut vex_mevent,
    pub highSensitivity: bool,
}
extern "C" {
    #[doc = " @brief Gets the value of the accelerometer.\n @return Returns an integer that represents the unit value specified by the parameter of the accelerometer sensor.\n @param units The measurement unit for the accelerometer device."]
    #[link_name = "\u{1}_ZN3vex13accelerometer5valueENS_11analogUnitsE"]
    pub fn vex_accelerometer_value(this: *mut vex_accelerometer, units: vex_analogUnits) -> i32;
}
extern "C" {
    #[doc = " @brief Gets the value of the accelerometer in G.\n @return Returns a double that represents the acceleration in G of the accelerometer sensor."]
    #[link_name = "\u{1}_ZN3vex13accelerometer12accelerationEv"]
    pub fn vex_accelerometer_acceleration(this: *mut vex_accelerometer) -> f64;
}
extern "C" {
    #[doc = " @brief Calls a function when the accelerometer value changes.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex13accelerometer7changedEPFvvE"]
    pub fn vex_accelerometer_changed(
        this: *mut vex_accelerometer,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Creates a new accelerometer object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex13accelerometerC1ERNS_7triport4portEb"]
    pub fn vex_accelerometer_accelerometer(
        this: *mut vex_accelerometer,
        port: *mut vex_triport_port,
        bHighSensitivity: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex13accelerometerD1Ev"]
    pub fn vex_accelerometer_accelerometer_destructor(this: *mut vex_accelerometer);
}
impl vex_accelerometer {
    #[inline]
    pub unsafe fn value(&mut self, units: vex_analogUnits) -> i32 {
        vex_accelerometer_value(self, units)
    }
    #[inline]
    pub unsafe fn acceleration(&mut self) -> f64 {
        vex_accelerometer_acceleration(self)
    }
    #[inline]
    pub unsafe fn changed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_accelerometer_changed(self, callback)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port, bHighSensitivity: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_accelerometer_accelerometer(__bindgen_tmp.as_mut_ptr(), port, bHighSensitivity);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_accelerometer_accelerometer_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with an analog-in device."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_analog_in {
    pub _base: vex___tridevice,
    pub CHANGED: *mut vex_mevent,
}
extern "C" {
    #[doc = " @brief Gets the value of the analog-in device.\n @return Returns an integer that represents the unit value specified by the parameter of the analog-in device.\n @param units The measurement unit for the analog-in device."]
    #[link_name = "\u{1}_ZN3vex9analog_in5valueENS_11analogUnitsE"]
    pub fn vex_analog_in_value(this: *mut vex_analog_in, units: vex_analogUnits) -> i32;
}
extern "C" {
    #[doc = " @brief Calls a function when the analog input value changes.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex9analog_in7changedEPFvvE"]
    pub fn vex_analog_in_changed(
        this: *mut vex_analog_in,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Creates a new analog-in object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex9analog_inC1ERNS_7triport4portE"]
    pub fn vex_analog_in_analog_in(this: *mut vex_analog_in, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex9analog_inD1Ev"]
    pub fn vex_analog_in_analog_in_destructor(this: *mut vex_analog_in);
}
impl vex_analog_in {
    #[inline]
    pub unsafe fn value(&mut self, units: vex_analogUnits) -> i32 {
        vex_analog_in_value(self, units)
    }
    #[inline]
    pub unsafe fn changed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_analog_in_changed(self, callback)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_analog_in_analog_in(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_analog_in_analog_in_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with an encoder."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_encoder {
    pub _base: vex___tridevice,
    pub CHANGED: *mut vex_mevent,
}
extern "C" {
    #[doc = " @brief Gets the value of the encoder.\n @return Returns an integer that represents the value of the encoder device."]
    #[link_name = "\u{1}_ZN3vex7encoder5valueEv"]
    pub fn vex_encoder_value(this: *mut vex_encoder) -> i32;
}
extern "C" {
    #[doc = " @brief Resets the rotation of the encoder to zero."]
    #[link_name = "\u{1}_ZN3vex7encoder13resetRotationEv"]
    pub fn vex_encoder_resetRotation(this: *mut vex_encoder);
}
extern "C" {
    #[doc = " @brief Sets the rotation of the encoder to a specific value.\n @param val Sets the amount of rotation.\n @param units The measurement unit for the rotation value."]
    #[link_name = "\u{1}_ZN3vex7encoder11setRotationEdNS_13rotationUnitsE"]
    pub fn vex_encoder_setRotation(this: *mut vex_encoder, val: f64, units: vex_rotationUnits);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7encoder11setPositionEdNS_13rotationUnitsE"]
    pub fn vex_encoder_setPosition(this: *mut vex_encoder, val: f64, units: vex_rotationUnits);
}
extern "C" {
    #[doc = " @brief Gets the rotation value of the encoder.\n @return Returns a double that represents the current rotation of the encoder.\n @param units The measurement unit for the encoder device."]
    #[link_name = "\u{1}_ZN3vex7encoder8rotationENS_13rotationUnitsE"]
    pub fn vex_encoder_rotation(this: *mut vex_encoder, units: vex_rotationUnits) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7encoder8positionENS_13rotationUnitsE"]
    pub fn vex_encoder_position(this: *mut vex_encoder, units: vex_rotationUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the velocity of the encoder.\n @return Returns a double that represents the current velocity of the encoder.\n @param units The measurement unit for the encoder device."]
    #[link_name = "\u{1}_ZN3vex7encoder8velocityENS_13velocityUnitsE"]
    pub fn vex_encoder_velocity(this: *mut vex_encoder, units: vex_velocityUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Calls a function when the encoder value changes.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex7encoder7changedEPFvvE"]
    pub fn vex_encoder_changed(
        this: *mut vex_encoder,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Creates a new encoder object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex7encoderC1ERNS_7triport4portE"]
    pub fn vex_encoder_encoder(this: *mut vex_encoder, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7encoderD1Ev"]
    pub fn vex_encoder_encoder_destructor(this: *mut vex_encoder);
}
impl vex_encoder {
    #[inline]
    pub unsafe fn value(&mut self) -> i32 {
        vex_encoder_value(self)
    }
    #[inline]
    pub unsafe fn resetRotation(&mut self) {
        vex_encoder_resetRotation(self)
    }
    #[inline]
    pub unsafe fn setRotation(&mut self, val: f64, units: vex_rotationUnits) {
        vex_encoder_setRotation(self, val, units)
    }
    #[inline]
    pub unsafe fn setPosition(&mut self, val: f64, units: vex_rotationUnits) {
        vex_encoder_setPosition(self, val, units)
    }
    #[inline]
    pub unsafe fn rotation(&mut self, units: vex_rotationUnits) -> f64 {
        vex_encoder_rotation(self, units)
    }
    #[inline]
    pub unsafe fn position(&mut self, units: vex_rotationUnits) -> f64 {
        vex_encoder_position(self, units)
    }
    #[inline]
    pub unsafe fn velocity(&mut self, units: vex_velocityUnits) -> f64 {
        vex_encoder_velocity(self, units)
    }
    #[inline]
    pub unsafe fn changed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_encoder_changed(self, callback)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_encoder_encoder(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_encoder_encoder_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a sonar sensor."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_sonar {
    pub _base: vex___tridevice,
    pub CHANGED: *mut vex_mevent,
    pub _maxdistance: u32,
    pub _mindistance: u32,
}
extern "C" {
    #[doc = " @brief Gets the value of the distance sensor.\n @return Returns an integer that represents the value of the sonar sensor."]
    #[link_name = "\u{1}_ZN3vex5sonar5valueEv"]
    pub fn vex_sonar_value(this: *mut vex_sonar) -> i32;
}
extern "C" {
    #[doc = " @brief Gets the value of the sonar sensor.\n @return Returns an integer that represents the unit value specified by the parameter of the sonar sensor.\n @param units The measurement unit for the sonar device."]
    #[link_name = "\u{1}_ZN3vex5sonar8distanceENS_13distanceUnitsE"]
    pub fn vex_sonar_distance(this: *mut vex_sonar, units: vex_distanceUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Calls a function when the sonar value changes.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex5sonar7changedEPFvvE"]
    pub fn vex_sonar_changed(
        this: *mut vex_sonar,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5sonar10setMaximumEdNS_13distanceUnitsE"]
    pub fn vex_sonar_setMaximum(this: *mut vex_sonar, distance: f64, units: vex_distanceUnits);
}
extern "C" {
    #[doc = " @brief Gets an object is present in front of the sonar sensor\n @return Returns a boolean that will be true if the sonar sensor is detecting an object."]
    #[link_name = "\u{1}_ZN3vex5sonar11foundObjectEv"]
    pub fn vex_sonar_foundObject(this: *mut vex_sonar) -> bool;
}
extern "C" {
    #[doc = " @brief Creates a new sonar object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex5sonarC1ERNS_7triport4portE"]
    pub fn vex_sonar_sonar(this: *mut vex_sonar, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5sonarD1Ev"]
    pub fn vex_sonar_sonar_destructor(this: *mut vex_sonar);
}
impl vex_sonar {
    #[inline]
    pub unsafe fn value(&mut self) -> i32 {
        vex_sonar_value(self)
    }
    #[inline]
    pub unsafe fn distance(&mut self, units: vex_distanceUnits) -> f64 {
        vex_sonar_distance(self, units)
    }
    #[inline]
    pub unsafe fn changed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_sonar_changed(self, callback)
    }
    #[inline]
    pub unsafe fn setMaximum(&mut self, distance: f64, units: vex_distanceUnits) {
        vex_sonar_setMaximum(self, distance, units)
    }
    #[inline]
    pub unsafe fn foundObject(&mut self) -> bool {
        vex_sonar_foundObject(self)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_sonar_sonar(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_sonar_sonar_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a pwm-out device."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_pwm_out {
    pub _base: vex___tridevice,
}
extern "C" {
    #[doc = " @brief Sets the state of the pwm device.\n @param value Sets the length of the pulse width.\n @param units The measurement unit for the state value."]
    #[link_name = "\u{1}_ZN3vex7pwm_out5stateEiNS_12percentUnitsE"]
    pub fn vex_pwm_out_state(this: *mut vex_pwm_out, value: i32, units: vex_percentUnits);
}
extern "C" {
    #[doc = " @brief Creates a new pwm-out object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex7pwm_outC1ERNS_7triport4portE"]
    pub fn vex_pwm_out_pwm_out(this: *mut vex_pwm_out, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7pwm_outD1Ev"]
    pub fn vex_pwm_out_pwm_out_destructor(this: *mut vex_pwm_out);
}
impl vex_pwm_out {
    #[inline]
    pub unsafe fn state(&mut self, value: i32, units: vex_percentUnits) {
        vex_pwm_out_state(self, value, units)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_pwm_out_pwm_out(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_pwm_out_pwm_out_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a servo device."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_servo {
    pub _base: vex___tridevice,
}
extern "C" {
    #[doc = " @brief Sets the position of the servo device.\n @param value Sets the amount of rotation.\n @param units The measurement unit for the rotation value."]
    #[link_name = "\u{1}_ZN3vex5servo11setPositionEiNS_12percentUnitsE"]
    pub fn vex_servo_setPosition(this: *mut vex_servo, value: i32, units: vex_percentUnits);
}
extern "C" {
    #[doc = " @brief Sets the position of the servo device.\n @param value Sets the amount of rotation.\n @param units The measurement unit for the rotation value."]
    #[link_name = "\u{1}_ZN3vex5servo11setPositionEdNS_13rotationUnitsE"]
    pub fn vex_servo_setPosition1(this: *mut vex_servo, value: f64, units: vex_rotationUnits);
}
extern "C" {
    #[doc = " @brief Creates a new servo object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex5servoC1ERNS_7triport4portE"]
    pub fn vex_servo_servo(this: *mut vex_servo, port: *mut vex_triport_port);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5servoD1Ev"]
    pub fn vex_servo_servo_destructor(this: *mut vex_servo);
}
impl vex_servo {
    #[inline]
    pub unsafe fn setPosition(&mut self, value: i32, units: vex_percentUnits) {
        vex_servo_setPosition(self, value, units)
    }
    #[inline]
    pub unsafe fn setPosition1(&mut self, value: f64, units: vex_rotationUnits) {
        vex_servo_setPosition1(self, value, units)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_servo_servo(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_servo_servo_destructor(self)
    }
}
#[doc = " @brief Use this class when programming a motor connected to a motor controller 29."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_motor29 {
    pub _base: vex___tridevice,
    pub _reversed: bool,
    pub _velocity: i32,
    pub _spinMode: bool,
}
extern "C" {
    #[doc = " @brief Sets the velocity of the motor based on the parameters set in the command. This command will not run the motor.  Any subsequent call that does not contain a specified motor velocity will use this value.\n @param velocity Sets the amount of velocity.\n @param units The measurement unit of the velocity value."]
    #[link_name = "\u{1}_ZN3vex7motor2911setVelocityEdNS_12percentUnitsE"]
    pub fn vex_motor29_setVelocity(this: *mut vex_motor29, velocity: f64, units: vex_percentUnits);
}
extern "C" {
    #[doc = " @brief Sets the motor mode to \"reverse\", which will make motor commands spin the motor in the opposite direction.\n @param value If set to true, the motor will spin in the reversed direction."]
    #[link_name = "\u{1}_ZN3vex7motor2911setReversedEb"]
    pub fn vex_motor29_setReversed(this: *mut vex_motor29, value: bool);
}
extern "C" {
    #[doc = " @brief Turns the motor on, and spins it in the specified direction.\n @param dir The direction to spin the motor."]
    #[link_name = "\u{1}_ZN3vex7motor294spinENS_13directionTypeE"]
    pub fn vex_motor29_spin(this: *mut vex_motor29, dir: vex_directionType);
}
extern "C" {
    #[doc = " @brief Turns on the motor and spins it in a specified direction and a specified velocity.\n @param dir The direction to spin the motor.\n @param velocity Sets the amount of velocity.\n @param units The measurement unit of the velocity value."]
    #[link_name = "\u{1}_ZN3vex7motor294spinENS_13directionTypeEdNS_13velocityUnitsE"]
    pub fn vex_motor29_spin1(
        this: *mut vex_motor29,
        dir: vex_directionType,
        velocity: f64,
        units: vex_velocityUnits,
    );
}
extern "C" {
    #[doc = " @brief Stops the motor using the default brake mode."]
    #[link_name = "\u{1}_ZN3vex7motor294stopEv"]
    pub fn vex_motor29_stop(this: *mut vex_motor29);
}
extern "C" {
    #[doc = " @brief Creates a new motor29 object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex7motor29C1ERNS_7triport4portE"]
    pub fn vex_motor29_motor29(this: *mut vex_motor29, port: *mut vex_triport_port);
}
extern "C" {
    #[doc = " @brief Creates a new motor29 object on the port specified in the parameter.\n @param port A reference to a three wire port.\n @param reverse Sets the reverse flag for the new motor29 object."]
    #[link_name = "\u{1}_ZN3vex7motor29C1ERNS_7triport4portEb"]
    pub fn vex_motor29_motor291(this: *mut vex_motor29, port: *mut vex_triport_port, reverse: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7motor29D1Ev"]
    pub fn vex_motor29_motor29_destructor(this: *mut vex_motor29);
}
impl vex_motor29 {
    #[inline]
    pub unsafe fn setVelocity(&mut self, velocity: f64, units: vex_percentUnits) {
        vex_motor29_setVelocity(self, velocity, units)
    }
    #[inline]
    pub unsafe fn setReversed(&mut self, value: bool) {
        vex_motor29_setReversed(self, value)
    }
    #[inline]
    pub unsafe fn spin(&mut self, dir: vex_directionType) {
        vex_motor29_spin(self, dir)
    }
    #[inline]
    pub unsafe fn spin1(
        &mut self,
        dir: vex_directionType,
        velocity: f64,
        units: vex_velocityUnits,
    ) {
        vex_motor29_spin1(self, dir, velocity, units)
    }
    #[inline]
    pub unsafe fn stop(&mut self) {
        vex_motor29_stop(self)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_motor29_motor29(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(port: *mut vex_triport_port, reverse: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_motor29_motor291(__bindgen_tmp.as_mut_ptr(), port, reverse);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_motor29_motor29_destructor(self)
    }
}
#[doc = " @brief Use this class when programming with a motor connected to a victor motor controller."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_motor_victor {
    pub _base: vex___tridevice,
    pub _reversed: bool,
    pub _velocity: i32,
    pub _spinMode: bool,
}
extern "C" {
    #[doc = " @brief Sets the velocity of the motor based on the parameters set in the command. This command will not run the motor.  Any subsequent call that does not contain a specified motor velocity will use this value.\n @param velocity Sets the amount of velocity.\n @param units The measurement unit of the velocity value."]
    #[link_name = "\u{1}_ZN3vex12motor_victor11setVelocityEdNS_12percentUnitsE"]
    pub fn vex_motor_victor_setVelocity(
        this: *mut vex_motor_victor,
        velocity: f64,
        units: vex_percentUnits,
    );
}
extern "C" {
    #[doc = " @brief Sets the motor mode to \"reverse\", which will make motor commands spin the motor in the opposite direction.\n @param value If set to true, the motor will spin in the reversed direction."]
    #[link_name = "\u{1}_ZN3vex12motor_victor11setReversedEb"]
    pub fn vex_motor_victor_setReversed(this: *mut vex_motor_victor, value: bool);
}
extern "C" {
    #[doc = " @brief Turns the motor on, and spins it in the specified direction.\n @param dir The direction to spin the motor."]
    #[link_name = "\u{1}_ZN3vex12motor_victor4spinENS_13directionTypeE"]
    pub fn vex_motor_victor_spin(this: *mut vex_motor_victor, dir: vex_directionType);
}
extern "C" {
    #[doc = " @brief Turns on the motor and spins it in a specified direction and a specified velocity.\n @param dir The direction to spin the motor.\n @param velocity Sets the amount of velocity.\n @param units The measurement unit of the velocity value."]
    #[link_name = "\u{1}_ZN3vex12motor_victor4spinENS_13directionTypeEdNS_13velocityUnitsE"]
    pub fn vex_motor_victor_spin1(
        this: *mut vex_motor_victor,
        dir: vex_directionType,
        velocity: f64,
        units: vex_velocityUnits,
    );
}
extern "C" {
    #[doc = " @brief Stops the motor using the default brake mode."]
    #[link_name = "\u{1}_ZN3vex12motor_victor4stopEv"]
    pub fn vex_motor_victor_stop(this: *mut vex_motor_victor);
}
extern "C" {
    #[doc = " @brief Creates a new motor victor object on the port specified in the parameter.\n @param port A reference to a three wire port."]
    #[link_name = "\u{1}_ZN3vex12motor_victorC1ERNS_7triport4portE"]
    pub fn vex_motor_victor_motor_victor(this: *mut vex_motor_victor, port: *mut vex_triport_port);
}
extern "C" {
    #[doc = " @brief Creates a new motor victor object on the port specified in the parameter.\n @param port A reference to a three wire port.\n @param reverse Sets the reverse flag for the new motor_victor object."]
    #[link_name = "\u{1}_ZN3vex12motor_victorC1ERNS_7triport4portEb"]
    pub fn vex_motor_victor_motor_victor1(
        this: *mut vex_motor_victor,
        port: *mut vex_triport_port,
        reverse: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex12motor_victorD1Ev"]
    pub fn vex_motor_victor_motor_victor_destructor(this: *mut vex_motor_victor);
}
impl vex_motor_victor {
    #[inline]
    pub unsafe fn setVelocity(&mut self, velocity: f64, units: vex_percentUnits) {
        vex_motor_victor_setVelocity(self, velocity, units)
    }
    #[inline]
    pub unsafe fn setReversed(&mut self, value: bool) {
        vex_motor_victor_setReversed(self, value)
    }
    #[inline]
    pub unsafe fn spin(&mut self, dir: vex_directionType) {
        vex_motor_victor_spin(self, dir)
    }
    #[inline]
    pub unsafe fn spin1(
        &mut self,
        dir: vex_directionType,
        velocity: f64,
        units: vex_velocityUnits,
    ) {
        vex_motor_victor_spin1(self, dir, velocity, units)
    }
    #[inline]
    pub unsafe fn stop(&mut self) {
        vex_motor_victor_stop(self)
    }
    #[inline]
    pub unsafe fn new(port: *mut vex_triport_port) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_motor_victor_motor_victor(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(port: *mut vex_triport_port, reverse: bool) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_motor_victor_motor_victor1(__bindgen_tmp.as_mut_ptr(), port, reverse);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_motor_victor_motor_victor_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7degreesE"]
    pub static vex_degrees: vex_rotationUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5turnsE"]
    pub static vex_turns: vex_rotationUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7percentE"]
    pub static vex_percent: vex_percentUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7secondsE"]
    pub static vex_seconds: vex_timeUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6inchesE"]
    pub static vex_inches: vex_distanceUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex2mmE"]
    pub static vex_mm: vex_distanceUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7forwardE"]
    pub static vex_forward: vex_directionType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7reverseE"]
    pub static vex_reverse: vex_directionType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4leftE"]
    pub static vex_left: vex_turnType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5rightE"]
    pub static vex_right: vex_turnType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5xaxisE"]
    pub static vex_xaxis: vex_axisType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5yaxisE"]
    pub static vex_yaxis: vex_axisType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5zaxisE"]
    pub static vex_zaxis: vex_axisType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4rollE"]
    pub static vex_roll: vex_orientationType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5pitchE"]
    pub static vex_pitch: vex_orientationType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex3yawE"]
    pub static vex_yaw: vex_orientationType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5monoME"]
    pub static vex_monoM: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5monoLE"]
    pub static vex_monoL: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6monoXLE"]
    pub static vex_monoXL: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7monoXXLE"]
    pub static vex_monoXXL: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5monoSE"]
    pub static vex_monoS: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6monoXSE"]
    pub static vex_monoXS: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5propME"]
    pub static vex_propM: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5propLE"]
    pub static vex_propL: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6propXLE"]
    pub static vex_propXL: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7propXXLE"]
    pub static vex_propXXL: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7primaryE"]
    pub static vex_primary: vex_controllerType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7partnerE"]
    pub static vex_partner: vex_controllerType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex10rumbleLongE"]
    pub static mut vex_rumbleLong: *const ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11rumbleShortE"]
    pub static mut vex_rumbleShort: *const ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11rumblePulseE"]
    pub static mut vex_rumblePulse: *const ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4waitEdNS_9timeUnitsE"]
    pub fn vex_wait(time: f64, units: vex_timeUnits);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5PORT1E"]
    pub static vex_PORT1: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5PORT2E"]
    pub static vex_PORT2: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5PORT3E"]
    pub static vex_PORT3: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5PORT4E"]
    pub static vex_PORT4: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5PORT5E"]
    pub static vex_PORT5: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5PORT6E"]
    pub static vex_PORT6: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5PORT7E"]
    pub static vex_PORT7: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5PORT8E"]
    pub static vex_PORT8: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5PORT9E"]
    pub static vex_PORT9: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT10E"]
    pub static vex_PORT10: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT11E"]
    pub static vex_PORT11: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT12E"]
    pub static vex_PORT12: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT13E"]
    pub static vex_PORT13: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT14E"]
    pub static vex_PORT14: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT15E"]
    pub static vex_PORT15: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT16E"]
    pub static vex_PORT16: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT17E"]
    pub static vex_PORT17: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT18E"]
    pub static vex_PORT18: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT19E"]
    pub static vex_PORT19: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT20E"]
    pub static vex_PORT20: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT21E"]
    pub static vex_PORT21: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6PORT22E"]
    pub static vex_PORT22: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex3pctE"]
    pub static vex_pct: vex_percentUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex3secE"]
    pub static vex_sec: vex_timeUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4msecE"]
    pub static vex_msec: vex_timeUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4voltE"]
    pub static vex_volt: vex_voltageUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex3ampE"]
    pub static vex_amp: vex_currentUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4wattE"]
    pub static vex_watt: vex_powerUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex2NmE"]
    pub static vex_Nm: vex_torqueUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4InLbE"]
    pub static vex_InLb: vex_torqueUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex3degE"]
    pub static vex_deg: vex_rotationUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex3revE"]
    pub static vex_rev: vex_rotationUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex3rpmE"]
    pub static vex_rpm: vex_velocityUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex3dpsE"]
    pub static vex_dps: vex_velocityUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex7celsiusE"]
    pub static vex_celsius: vex_temperatureUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex10fahrenheitE"]
    pub static vex_fahrenheit: vex_temperatureUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex3fwdE"]
    pub static vex_fwd: vex_directionType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5coastE"]
    pub static vex_coast: vex_brakeType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5brakeE"]
    pub static vex_brake: vex_brakeType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4holdE"]
    pub static vex_hold: vex_brakeType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex9ratio36_1E"]
    pub static vex_ratio36_1: vex_gearSetting;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex9ratio18_1E"]
    pub static vex_ratio18_1: vex_gearSetting;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex8ratio6_1E"]
    pub static vex_ratio6_1: vex_gearSetting;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5blackE"]
    pub static mut vex_black: *const vex_color;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5whiteE"]
    pub static mut vex_white: *const vex_color;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex3redE"]
    pub static mut vex_red: *const vex_color;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5greenE"]
    pub static mut vex_green: *const vex_color;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4blueE"]
    pub static mut vex_blue: *const vex_color;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6yellowE"]
    pub static mut vex_yellow: *const vex_color;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6orangeE"]
    pub static mut vex_orange: *const vex_color;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6purpleE"]
    pub static mut vex_purple: *const vex_color;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex4cyanE"]
    pub static mut vex_cyan: *const vex_color;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11transparentE"]
    pub static mut vex_transparent: *const vex_color;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6mono20E"]
    pub static vex_mono20: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6mono30E"]
    pub static vex_mono30: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6mono40E"]
    pub static vex_mono40: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6mono60E"]
    pub static vex_mono60: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6mono15E"]
    pub static vex_mono15: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6mono12E"]
    pub static vex_mono12: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6prop20E"]
    pub static vex_prop20: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6prop30E"]
    pub static vex_prop30: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6prop40E"]
    pub static vex_prop40: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex6prop60E"]
    pub static vex_prop60: vex_fontType;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex9range8bitE"]
    pub static vex_range8bit: vex_analogUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex10range10bitE"]
    pub static vex_range10bit: vex_analogUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex10range12bitE"]
    pub static vex_range12bit: vex_analogUnits;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex2mVE"]
    pub static vex_mV: vex_analogUnits;
}
#[doc = " @brief Use the brain class to see battery information, SD card information, or write to the Screen."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_brain {
    #[doc = " @brief Use the Screen class to write or draw to the screen."]
    pub Screen: vex_brain_lcd,
    #[doc = " @brief Use the Timer class to obtain the system time."]
    pub Timer: vex_timer,
    #[doc = " @brief The Brain's instance of Three Wire Ports A through H."]
    pub ThreeWirePort: vex_triport,
    #[doc = " @brief This is the Brain's instance of the battery."]
    pub Battery: vex_brain_battery,
    #[doc = " @brief This is the instance of the SD card class."]
    pub SDcard: vex_brain_sdcard,
}
pub const vex_brain_tEventType_EVENT_LCD_PRESSED: vex_brain_tEventType = 0;
pub const vex_brain_tEventType_EVENT_LCD_RELEASED: vex_brain_tEventType = 1;
pub type vex_brain_tEventType = ::core::ffi::c_int;
#[doc = " @brief Use this class to write or draw to the brain's LCD screen."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_brain_lcd {
    pub _row: i32,
    pub _maxrows: i32,
    pub _rowheight: i32,
    pub _col: i32,
    pub _maxcols: i32,
    pub _colwidth: i32,
    pub _penWidth: i32,
    pub _textbase: u32,
    pub _textStr: [::core::ffi::c_char; 256usize],
    pub _transparent: bool,
    pub _origin_x: ::core::ffi::c_int,
    pub _origin_y: ::core::ffi::c_int,
    pub PRESSED: vex_mevent,
    pub RELEASED: vex_mevent,
}
pub const vex_brain_lcd_tImageBufferType_kImageBufferTypeUnknown: vex_brain_lcd_tImageBufferType =
    0;
pub const vex_brain_lcd_tImageBufferType_kImageBufferTypeBmp: vex_brain_lcd_tImageBufferType = 1;
pub const vex_brain_lcd_tImageBufferType_kImageBufferTypePng: vex_brain_lcd_tImageBufferType = 2;
pub type vex_brain_lcd_tImageBufferType = ::core::ffi::c_int;
extern "C" {
    #[doc = " @brief Sets the cursor to the row and column number set in the parameters.\n @param row Sets the row number for where the cursor is placed.\n @param col Sets the column number for where the cursor is placed."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd9setCursorEii"]
    pub fn vex_brain_lcd_setCursor(this: *mut vex_brain_lcd, row: i32, col: i32);
}
extern "C" {
    #[doc = " @brief Sets the font type to be displayed on the Screen that is determined by the parameter.\n @param font The type of font that is displayed."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd7setFontENS_8fontTypeE"]
    pub fn vex_brain_lcd_setFont(this: *mut vex_brain_lcd, font: vex_fontType);
}
extern "C" {
    #[doc = " @brief Sets the pen's width.\n @param width This represents the width of the pen when drawing. A larger width equals a wider pen stroke."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd11setPenWidthEj"]
    pub fn vex_brain_lcd_setPenWidth(this: *mut vex_brain_lcd, width: u32);
}
extern "C" {
    #[doc = " @brief Sets the origin of the screen to the parameters defined in the function.\n @param x The x location of the origin.\n @param y The y location of the origin."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd9setOriginEii"]
    pub fn vex_brain_lcd_setOrigin(this: *mut vex_brain_lcd, x: i32, y: i32);
}
extern "C" {
    #[doc = " @brief An integer that tracks the current cursor position's column, starting at 1.\n @return Returns an integer that tracks the current cursor position's column, starting at 1."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd6columnEv"]
    pub fn vex_brain_lcd_column(this: *mut vex_brain_lcd) -> i32;
}
extern "C" {
    #[doc = " @brief An integer that tracks the current cursor position's row, starting at 1.\n @return Returns an integer that tracks the current cursor position's row, starting at 1."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd3rowEv"]
    pub fn vex_brain_lcd_row(this: *mut vex_brain_lcd) -> i32;
}
extern "C" {
    #[doc = " @brief Sets the color of the pen to a specified color.\n @param color A color unit where colors can be defined as names."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd11setPenColorERKNS_5colorE"]
    pub fn vex_brain_lcd_setPenColor(this: *mut vex_brain_lcd, color: *const vex_color);
}
extern "C" {
    #[doc = " @brief Sets the color of the pen to a specified color using a hex value.\n @param color A hexadecimal value that represents color."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd11setPenColorEPKc"]
    pub fn vex_brain_lcd_setPenColor1(this: *mut vex_brain_lcd, color: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Sets the color of the pen to a specified color.\n @param hue The integer represents the hue of the color."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd11setPenColorEi"]
    pub fn vex_brain_lcd_setPenColor2(this: *mut vex_brain_lcd, hue: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief Sets the default fill color for any subsequent draw command.\n @param color In a color unit, colors can be defined as names."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd12setFillColorERKNS_5colorE"]
    pub fn vex_brain_lcd_setFillColor(this: *mut vex_brain_lcd, color: *const vex_color);
}
extern "C" {
    #[doc = " @brief Sets the default fill color for any subsequent draw command..\n @param color A hexadecimal value that represents color."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd12setFillColorEPKc"]
    pub fn vex_brain_lcd_setFillColor1(this: *mut vex_brain_lcd, color: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Sets the default fill color for any subsequent draw command.\n @param hue The integer represents the hue of the color."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd12setFillColorEi"]
    pub fn vex_brain_lcd_setFillColor2(this: *mut vex_brain_lcd, hue: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief Gets the width in pixels of the given string.\n @return Returns an integer that represents the width of the string in pixels."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd14getStringWidthEPKc"]
    pub fn vex_brain_lcd_getStringWidth(
        this: *mut vex_brain_lcd,
        cstr: *const ::core::ffi::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Gets the height in pixels of the given string.\n @return Returns an integer that represents the height of the string in pixels."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd15getStringHeightEPKc"]
    pub fn vex_brain_lcd_getStringHeight(
        this: *mut vex_brain_lcd,
        cstr: *const ::core::ffi::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Prints a number, string, or Boolean.\n @param value Information to display on the screen.\n/\n/**\n @brief Prints a number, string, or Boolean.\n @param format This is a reference to a char format that prints the value of variables.\n @param ... A variable list of parameters to insert into format string."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd5printEPKcz"]
    pub fn vex_brain_lcd_print(this: *mut vex_brain_lcd, format: *const ::core::ffi::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5brain3lcd5printEPcz"]
    pub fn vex_brain_lcd_print1(this: *mut vex_brain_lcd, format: *mut ::core::ffi::c_char, ...);
}
extern "C" {
    #[doc = " @brief Prints a number, string, or Boolean at an x, y pixel location.\n @param x The x-coordinate at which to print a message on the screen.\n @param y The y-coordinate at which to print a message on the screen.\n @param format A reference to a char format to print the value of variables.\n @param ... A variable list of parameters to insert into format string."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd7printAtEiiPKcz"]
    pub fn vex_brain_lcd_printAt(
        this: *mut vex_brain_lcd,
        x: i32,
        y: i32,
        format: *const ::core::ffi::c_char,
        ...
    );
}
extern "C" {
    #[doc = " @brief Prints a number, string, or Boolean at an x, y pixel location with the ability to be transparent.\n @param x The x pixel location where the print should start\n @param y The y pixel location where the print should start\n @param bOpaque If set to false, the print will be transparent.\n @param format A reference to a char format to print the value of variables.\n @param ... A variable list of parameters to insert into format string."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd7printAtEiibPKcz"]
    pub fn vex_brain_lcd_printAt1(
        this: *mut vex_brain_lcd,
        x: i32,
        y: i32,
        bOpaque: bool,
        format: *const ::core::ffi::c_char,
        ...
    );
}
extern "C" {
    #[doc = " @brief Clears the whole Screen to a default color or otherwise specified color."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd11clearScreenEv"]
    pub fn vex_brain_lcd_clearScreen(this: *mut vex_brain_lcd);
}
extern "C" {
    #[doc = " @brief Clears the whole Screen to a default color or otherwise specified color.\n @param color In a color unit, colors can be defined as names."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd11clearScreenERKNS_5colorE"]
    pub fn vex_brain_lcd_clearScreen1(this: *mut vex_brain_lcd, color: *const vex_color);
}
extern "C" {
    #[doc = " @brief Clears the whole Screen to a default color or otherwise specified color.\n @param color A hexadecimal value that represents color."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd11clearScreenEPKc"]
    pub fn vex_brain_lcd_clearScreen2(this: *mut vex_brain_lcd, color: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Clears the whole Screen to a default color or otherwise specified color.\n @param hue The integer represents the hue of the color."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd11clearScreenEi"]
    pub fn vex_brain_lcd_clearScreen3(this: *mut vex_brain_lcd, hue: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief Clears the specified line and sets it to a specified color.\n @param number The integer sets the line that is to be cleared.\n @param color A color unit where colors can be defined as names."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd9clearLineEiRKNS_5colorE"]
    pub fn vex_brain_lcd_clearLine(
        this: *mut vex_brain_lcd,
        number: ::core::ffi::c_int,
        color: *const vex_color,
    );
}
extern "C" {
    #[doc = " @brief Clears the specified line and sets it to a specified color.\n @param number The integer sets the line that is to be cleared.\n @param color A hexadecimal value that represents color."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd9clearLineEiPKc"]
    pub fn vex_brain_lcd_clearLine1(
        this: *mut vex_brain_lcd,
        number: ::core::ffi::c_int,
        color: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " @brief Clears the specified line and sets it to a specified color.\n @param number The integer sets the line that is to be cleared.\n @param hue An integer that represents the hue of the color."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd9clearLineEii"]
    pub fn vex_brain_lcd_clearLine2(
        this: *mut vex_brain_lcd,
        number: ::core::ffi::c_int,
        hue: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief Clears the specified line and sets it to the background color.\n @param number The integer sets the line that is to be cleared."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd9clearLineEi"]
    pub fn vex_brain_lcd_clearLine3(this: *mut vex_brain_lcd, number: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief Clears the rest of the line from where the cursor is located."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd9clearLineEv"]
    pub fn vex_brain_lcd_clearLine4(this: *mut vex_brain_lcd);
}
extern "C" {
    #[doc = " @brief Clears the rest of the line from where the cursor is located and then moves the cursor to the beginning of the next line."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd7newLineEv"]
    pub fn vex_brain_lcd_newLine(this: *mut vex_brain_lcd);
}
extern "C" {
    #[doc = " @brief Draws a single pixel to the screen in the specified x and y location.\n @param x The x location of where to draw the pixel.\n @param y The y location of where to draw the pixel."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd9drawPixelEii"]
    pub fn vex_brain_lcd_drawPixel(
        this: *mut vex_brain_lcd,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief Draws a line connecting the two specified points in the parameters.\n @param x1 The x location of the first point.\n @param y1 The y location of the first point.\n @param x2 The x location of the second point.\n @param y2 The y location of the second point."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd8drawLineEiiii"]
    pub fn vex_brain_lcd_drawLine(
        this: *mut vex_brain_lcd,
        x1: ::core::ffi::c_int,
        y1: ::core::ffi::c_int,
        x2: ::core::ffi::c_int,
        y2: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief Draws a rectangle using the specified points and attributes set in the parameters. Fills the rectangle with the current pen and fill color.\n @param x The x-coordinate at which the left edge of the rectangle will be drawn on the screen.\n @param y The y-coordinate at which the top edge of the rectangle will be drawn on the screen.\n @param width The width of the rectangle.\n @param height The height of the rectangle."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd13drawRectangleEiiii"]
    pub fn vex_brain_lcd_drawRectangle(
        this: *mut vex_brain_lcd,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief Draws a rectangle using the specified points and attributes set in the parameters. Fills the rectangle with the color specified.\n @param x The x-coordinate at which the left edge of the rectangle will be drawn on the screen.\n @param y The y-coordinate at which the top edge of the rectangle will be drawn on the screen.\n @param width The width of the rectangle.\n @param height The height of the rectangle.\n @param color A color unit where colors can be defined as names."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd13drawRectangleEiiiiRKNS_5colorE"]
    pub fn vex_brain_lcd_drawRectangle1(
        this: *mut vex_brain_lcd,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        color: *const vex_color,
    );
}
extern "C" {
    #[doc = " @brief Draws a rectangle using the specified points and attributes set in the parameters. Fills the rectangle with the color specified.\n @param x The x-coordinate at which the left edge of the rectangle will be drawn on the screen.\n @param y The y-coordinate at which the top edge of the rectangle will be drawn on the screen.\n @param width The width of the rectangle.\n @param height The height of the rectangle.\n @param color A hexadecimal value that represents color."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd13drawRectangleEiiiiPKc"]
    pub fn vex_brain_lcd_drawRectangle2(
        this: *mut vex_brain_lcd,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        color: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " @brief Draws a rectangle using the specified points and attributes set in the parameters. Fills the rectangle with the color specified.\n @param x The x-coordinate at which the left edge of the rectangle will be drawn on the screen.\n @param y The y-coordinate at which the top edge of the rectangle will be drawn on the screen.\n @param width The width of the rectangle.\n @param height The height of the rectangle.\n @param hue The color of the rectangle."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd13drawRectangleEiiiii"]
    pub fn vex_brain_lcd_drawRectangle3(
        this: *mut vex_brain_lcd,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        hue: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief Draws a circle using the specified points and attributes set in the parameters. Fills the circle with the current pen and fill color.\n @param x The central x location of the circle.\n @param y The central y location of the circle.\n @param radius Sets the radius of the circle to be drawn on the Screen."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd10drawCircleEiii"]
    pub fn vex_brain_lcd_drawCircle(
        this: *mut vex_brain_lcd,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        radius: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief Draws a circle using the specified points and attributes set in the parameters. Fills the circle with the color specified.\n @param x The central x location of the circle.\n @param y The central y location of the circle.\n @param radius Sets the radius of the circle to be drawn on the Screen.\n @param color A color unit where colors can be defined as names."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd10drawCircleEiiiRKNS_5colorE"]
    pub fn vex_brain_lcd_drawCircle1(
        this: *mut vex_brain_lcd,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        radius: ::core::ffi::c_int,
        color: *const vex_color,
    );
}
extern "C" {
    #[doc = " @brief Draws a circle using the specified points and attributes set in the parameters. Fills the circle with the color specified.\n @param x The central x location of the circle.\n @param y The central y location of the circle.\n @param radius Sets the radius of the circle to be drawn on the Screen.\n @param color A hexadecimal value that represents color."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd10drawCircleEiiiPKc"]
    pub fn vex_brain_lcd_drawCircle2(
        this: *mut vex_brain_lcd,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        radius: ::core::ffi::c_int,
        color: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[doc = " @brief Draws a circle using the specified points and attributes set in the parameters. Fills the circle with the color specified.\n @param x The central x location of the circle.\n @param y The central y location of the circle.\n @param radius Sets the radius of the circle to be drawn on the Screen.\n @param hue An integer that represents the hue of the color."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd10drawCircleEiiii"]
    pub fn vex_brain_lcd_drawCircle3(
        this: *mut vex_brain_lcd,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        radius: ::core::ffi::c_int,
        hue: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief Sets the function to be called when the Screen is pressed.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd7pressedEPFvvE"]
    pub fn vex_brain_lcd_pressed(
        this: *mut vex_brain_lcd,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Sets the function to be called when the Screen is pressed.  A void pointer may be passed to the callback.\n @param callback A reference to a function.\n @param arg A void pointer that will be passed to the callback."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd7pressedEPFvPvES2_"]
    pub fn vex_brain_lcd_pressed1(
        this: *mut vex_brain_lcd,
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Sets the function to be called when the screen is released after being pressed.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd8releasedEPFvvE"]
    pub fn vex_brain_lcd_released(
        this: *mut vex_brain_lcd,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Sets the function to be called when the screen is released after being pressed.  A void pointer may be passed to the callback.\n @param callback A reference to a function.\n @param arg A void pointer that will be passed to the callback."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd8releasedEPFvPvES2_"]
    pub fn vex_brain_lcd_released1(
        this: *mut vex_brain_lcd,
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief Gets the last x location pressed on the screen.\n @return Returns an integer that represents the last x location pressed on the screen."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd9xPositionEv"]
    pub fn vex_brain_lcd_xPosition(this: *mut vex_brain_lcd) -> i32;
}
extern "C" {
    #[doc = " @brief Gets the last y location pressed on the screen.\n @return Returns an integer that represents the last y location pressed on the screen."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd9yPositionEv"]
    pub fn vex_brain_lcd_yPosition(this: *mut vex_brain_lcd) -> i32;
}
extern "C" {
    #[doc = " @brief Gets the pressed status of the Screen.\n @return Returns a Boolean based on the state of a press on the screen. If the screen is pressed, the Boolean will be true, if the button is released, the Boolean will be false."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd8pressingEv"]
    pub fn vex_brain_lcd_pressing(this: *mut vex_brain_lcd) -> bool;
}
extern "C" {
    #[doc = " @brief Switches to double buffering or renders back buffer to screen.\n @return Returns true if the back buffer was successfully copied to the screen."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd6renderEv"]
    pub fn vex_brain_lcd_render(this: *mut vex_brain_lcd) -> bool;
}
extern "C" {
    #[doc = " @brief Switches to double buffering or renders back buffer to screen.\n @param bVsyncWait If true, wait for the Vsync signal to render.\n @param bRunScheduler (Optional) If true, run background tasks while waiting to render. By default, this parameter is true.\n @return Returns true if the back buffer was successfully copied to the screen."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd6renderEbb"]
    pub fn vex_brain_lcd_render1(
        this: *mut vex_brain_lcd,
        bVsyncWait: bool,
        bRunScheduler: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Sets the clip region for screen output.  Only effects the current thread.\n @param x The x-coordinate at the left edge of the clip region.\n @param y The y-coordinate at the top edge of the clip region.\n @param width The width of the clip region.\n @param height The height of the clip region."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd13setClipRegionEiiii"]
    pub fn vex_brain_lcd_setClipRegion(
        this: *mut vex_brain_lcd,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief Draws an image on the screen using the contents of the memory buffer.\n @param buffer A pointer to a buffer containing image data in either bmp or png format.\n @param x The x-coordinate at which the left edge of the image will be drawn.\n @param y The y-coordinate at which the top edge of the image will be drawn.\n @param bufferLen The size of the source image buffer in bytes.\n @return Returns true if the image was successfully drawn on the screen.\n @details\n  This function draws an image on the screen using the contents of a buffer into which\n  either BMP or PNG raw data has already been read.  The contents may have come from a\n  file on the SD card or have been statically declared in the code.  The image should be\n  no larger than the V5 Screen, that is, a maximum of 480 pixels wide by 272 pixels high.\n  The top/left corner of the image is placed at the coordinates given by x and y, these can\n  be negative if desired."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd19drawImageFromBufferEPhiii"]
    pub fn vex_brain_lcd_drawImageFromBuffer(
        this: *mut vex_brain_lcd,
        buffer: *mut u8,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        bufferLen: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Draws an image on the screen using the contents of the memory buffer.\n @param buffer A pointer to a buffer containing raw 32 bit per pixel image data.\n @param x The x-coordinate at which the left edge of the image will be drawn.\n @param y The y-coordinate at which the top edge of the image will be drawn.\n @param width The width of the image.\n @param height The height of the image.\n @return Returns true if the image was successfully drawn on the screen.\n @details\n  This funtion draws an image on the screen using the contents of a buffer into which\n  raw RGB pixels have been placed.  Each pixel is represented by a 32 bit value, however,\n  only the lower 24 bits are used as transparency is not yet supported.  The buffer contains\n  pixels for the first row of the image immediately followed by pixels for the second row and so on.\n  The image should be no larger than the V5 Screen, that is, a maximum of 480 pixels wide by 272 pixels high.\n  The top/left corner of the image is placed at the coordinates given by x and y, these can\n  be negative if desired."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd19drawImageFromBufferEPjiiii"]
    pub fn vex_brain_lcd_drawImageFromBuffer1(
        this: *mut vex_brain_lcd,
        buffer: *mut u32,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Draws an image on the screen using a file on the SD Card as the source.\n @param name The name of the image, it must have either a \".bmp\" or \".png\" extension.\n @param x The x-coordinate at which the left edge of the image will be drawn.\n @param y The y-coordinate at which the top edge of the image will be drawn.\n @return Returns true if the image was successfully drawn on the screen.\n @details\n  This funtion draws an image on the screen using the contents of a file on an SD Card.\n  The file should be no larger than 512K bytes and must have either a \".bmp\" or \".png\" extension.\n  The image should be no larger than the V5 Screen, that is, a maximum of 480 pixels wide by 272 pixels high.\n  The top/left corner of the image is placed at the coordinates given by x and y, these can\n  be negative if desired."]
    #[link_name = "\u{1}_ZN3vex5brain3lcd17drawImageFromFileEPKcii"]
    pub fn vex_brain_lcd_drawImageFromFile(
        this: *mut vex_brain_lcd,
        name: *const ::core::ffi::c_char,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5brain3lcd14waitForRefreshEv"]
    pub fn vex_brain_lcd_waitForRefresh(this: *mut vex_brain_lcd);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5brain3lcd13renderDisableEv"]
    pub fn vex_brain_lcd_renderDisable(this: *mut vex_brain_lcd);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5brain3lcdC1Ev"]
    pub fn vex_brain_lcd_lcd(this: *mut vex_brain_lcd);
}
impl vex_brain_lcd {
    #[inline]
    pub unsafe fn setCursor(&mut self, row: i32, col: i32) {
        vex_brain_lcd_setCursor(self, row, col)
    }
    #[inline]
    pub unsafe fn setFont(&mut self, font: vex_fontType) {
        vex_brain_lcd_setFont(self, font)
    }
    #[inline]
    pub unsafe fn setPenWidth(&mut self, width: u32) {
        vex_brain_lcd_setPenWidth(self, width)
    }
    #[inline]
    pub unsafe fn setOrigin(&mut self, x: i32, y: i32) {
        vex_brain_lcd_setOrigin(self, x, y)
    }
    #[inline]
    pub unsafe fn column(&mut self) -> i32 {
        vex_brain_lcd_column(self)
    }
    #[inline]
    pub unsafe fn row(&mut self) -> i32 {
        vex_brain_lcd_row(self)
    }
    #[inline]
    pub unsafe fn setPenColor(&mut self, color: *const vex_color) {
        vex_brain_lcd_setPenColor(self, color)
    }
    #[inline]
    pub unsafe fn setPenColor1(&mut self, color: *const ::core::ffi::c_char) {
        vex_brain_lcd_setPenColor1(self, color)
    }
    #[inline]
    pub unsafe fn setPenColor2(&mut self, hue: ::core::ffi::c_int) {
        vex_brain_lcd_setPenColor2(self, hue)
    }
    #[inline]
    pub unsafe fn setFillColor(&mut self, color: *const vex_color) {
        vex_brain_lcd_setFillColor(self, color)
    }
    #[inline]
    pub unsafe fn setFillColor1(&mut self, color: *const ::core::ffi::c_char) {
        vex_brain_lcd_setFillColor1(self, color)
    }
    #[inline]
    pub unsafe fn setFillColor2(&mut self, hue: ::core::ffi::c_int) {
        vex_brain_lcd_setFillColor2(self, hue)
    }
    #[inline]
    pub unsafe fn getStringWidth(&mut self, cstr: *const ::core::ffi::c_char) -> i32 {
        vex_brain_lcd_getStringWidth(self, cstr)
    }
    #[inline]
    pub unsafe fn getStringHeight(&mut self, cstr: *const ::core::ffi::c_char) -> i32 {
        vex_brain_lcd_getStringHeight(self, cstr)
    }
    #[inline]
    pub unsafe fn clearScreen(&mut self) {
        vex_brain_lcd_clearScreen(self)
    }
    #[inline]
    pub unsafe fn clearScreen1(&mut self, color: *const vex_color) {
        vex_brain_lcd_clearScreen1(self, color)
    }
    #[inline]
    pub unsafe fn clearScreen2(&mut self, color: *const ::core::ffi::c_char) {
        vex_brain_lcd_clearScreen2(self, color)
    }
    #[inline]
    pub unsafe fn clearScreen3(&mut self, hue: ::core::ffi::c_int) {
        vex_brain_lcd_clearScreen3(self, hue)
    }
    #[inline]
    pub unsafe fn clearLine(&mut self, number: ::core::ffi::c_int, color: *const vex_color) {
        vex_brain_lcd_clearLine(self, number, color)
    }
    #[inline]
    pub unsafe fn clearLine1(
        &mut self,
        number: ::core::ffi::c_int,
        color: *const ::core::ffi::c_char,
    ) {
        vex_brain_lcd_clearLine1(self, number, color)
    }
    #[inline]
    pub unsafe fn clearLine2(&mut self, number: ::core::ffi::c_int, hue: ::core::ffi::c_int) {
        vex_brain_lcd_clearLine2(self, number, hue)
    }
    #[inline]
    pub unsafe fn clearLine3(&mut self, number: ::core::ffi::c_int) {
        vex_brain_lcd_clearLine3(self, number)
    }
    #[inline]
    pub unsafe fn clearLine4(&mut self) {
        vex_brain_lcd_clearLine4(self)
    }
    #[inline]
    pub unsafe fn newLine(&mut self) {
        vex_brain_lcd_newLine(self)
    }
    #[inline]
    pub unsafe fn drawPixel(&mut self, x: ::core::ffi::c_int, y: ::core::ffi::c_int) {
        vex_brain_lcd_drawPixel(self, x, y)
    }
    #[inline]
    pub unsafe fn drawLine(
        &mut self,
        x1: ::core::ffi::c_int,
        y1: ::core::ffi::c_int,
        x2: ::core::ffi::c_int,
        y2: ::core::ffi::c_int,
    ) {
        vex_brain_lcd_drawLine(self, x1, y1, x2, y2)
    }
    #[inline]
    pub unsafe fn drawRectangle(
        &mut self,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) {
        vex_brain_lcd_drawRectangle(self, x, y, width, height)
    }
    #[inline]
    pub unsafe fn drawRectangle1(
        &mut self,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        color: *const vex_color,
    ) {
        vex_brain_lcd_drawRectangle1(self, x, y, width, height, color)
    }
    #[inline]
    pub unsafe fn drawRectangle2(
        &mut self,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        color: *const ::core::ffi::c_char,
    ) {
        vex_brain_lcd_drawRectangle2(self, x, y, width, height, color)
    }
    #[inline]
    pub unsafe fn drawRectangle3(
        &mut self,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        hue: ::core::ffi::c_int,
    ) {
        vex_brain_lcd_drawRectangle3(self, x, y, width, height, hue)
    }
    #[inline]
    pub unsafe fn drawCircle(
        &mut self,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        radius: ::core::ffi::c_int,
    ) {
        vex_brain_lcd_drawCircle(self, x, y, radius)
    }
    #[inline]
    pub unsafe fn drawCircle1(
        &mut self,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        radius: ::core::ffi::c_int,
        color: *const vex_color,
    ) {
        vex_brain_lcd_drawCircle1(self, x, y, radius, color)
    }
    #[inline]
    pub unsafe fn drawCircle2(
        &mut self,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        radius: ::core::ffi::c_int,
        color: *const ::core::ffi::c_char,
    ) {
        vex_brain_lcd_drawCircle2(self, x, y, radius, color)
    }
    #[inline]
    pub unsafe fn drawCircle3(
        &mut self,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        radius: ::core::ffi::c_int,
        hue: ::core::ffi::c_int,
    ) {
        vex_brain_lcd_drawCircle3(self, x, y, radius, hue)
    }
    #[inline]
    pub unsafe fn pressed(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_brain_lcd_pressed(self, callback)
    }
    #[inline]
    pub unsafe fn pressed1(
        &mut self,
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
    ) {
        vex_brain_lcd_pressed1(self, callback, arg)
    }
    #[inline]
    pub unsafe fn released(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_brain_lcd_released(self, callback)
    }
    #[inline]
    pub unsafe fn released1(
        &mut self,
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
    ) {
        vex_brain_lcd_released1(self, callback, arg)
    }
    #[inline]
    pub unsafe fn xPosition(&mut self) -> i32 {
        vex_brain_lcd_xPosition(self)
    }
    #[inline]
    pub unsafe fn yPosition(&mut self) -> i32 {
        vex_brain_lcd_yPosition(self)
    }
    #[inline]
    pub unsafe fn pressing(&mut self) -> bool {
        vex_brain_lcd_pressing(self)
    }
    #[inline]
    pub unsafe fn render(&mut self) -> bool {
        vex_brain_lcd_render(self)
    }
    #[inline]
    pub unsafe fn render1(&mut self, bVsyncWait: bool, bRunScheduler: bool) -> bool {
        vex_brain_lcd_render1(self, bVsyncWait, bRunScheduler)
    }
    #[inline]
    pub unsafe fn setClipRegion(
        &mut self,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) {
        vex_brain_lcd_setClipRegion(self, x, y, width, height)
    }
    #[inline]
    pub unsafe fn drawImageFromBuffer(
        &mut self,
        buffer: *mut u8,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        bufferLen: ::core::ffi::c_int,
    ) -> bool {
        vex_brain_lcd_drawImageFromBuffer(self, buffer, x, y, bufferLen)
    }
    #[inline]
    pub unsafe fn drawImageFromBuffer1(
        &mut self,
        buffer: *mut u32,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    ) -> bool {
        vex_brain_lcd_drawImageFromBuffer1(self, buffer, x, y, width, height)
    }
    #[inline]
    pub unsafe fn drawImageFromFile(
        &mut self,
        name: *const ::core::ffi::c_char,
        x: ::core::ffi::c_int,
        y: ::core::ffi::c_int,
    ) -> bool {
        vex_brain_lcd_drawImageFromFile(self, name, x, y)
    }
    #[inline]
    pub unsafe fn waitForRefresh(&mut self) {
        vex_brain_lcd_waitForRefresh(self)
    }
    #[inline]
    pub unsafe fn renderDisable(&mut self) {
        vex_brain_lcd_renderDisable(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_brain_lcd_lcd(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " @brief Use the battery class to see information about the battery."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_brain_battery {
    pub _address: u8,
}
extern "C" {
    #[doc = " @brief Gets the battery capacity.\n @return Returns an integer that represents the batteries capacity in the units specified by the parameter.\n @param units (Optional) The type of unit that will be returned. By default, this parameter is a percentage."]
    #[link_name = "\u{1}_ZN3vex5brain7battery8capacityENS_12percentUnitsE"]
    pub fn vex_brain_battery_capacity(this: *mut vex_brain_battery, units: vex_percentUnits)
        -> u32;
}
extern "C" {
    #[doc = " @brief Gets the battery temperature.\n @return Returns a double that represents the batteries temperature in the units specified by the parameter.\n @param units (Optional) The type of unit that will be returned. By default, this parameter is a percentage."]
    #[link_name = "\u{1}_ZN3vex5brain7battery11temperatureENS_12percentUnitsE"]
    pub fn vex_brain_battery_temperature(
        this: *mut vex_brain_battery,
        units: vex_percentUnits,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the battery temperature.\n @return Returns a double that represents the batteries temperature in the units specified by the parameter.\n @param units The unit of temperature that will be returned."]
    #[link_name = "\u{1}_ZN3vex5brain7battery11temperatureENS_16temperatureUnitsE"]
    pub fn vex_brain_battery_temperature1(
        this: *mut vex_brain_battery,
        units: vex_temperatureUnits,
    ) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the battery voltage.\n @return Returns a double that represents the batteries voltage in the units specified by the parameter.\n @param units The unit of voltage to be returned."]
    #[link_name = "\u{1}_ZN3vex5brain7battery7voltageENS_12voltageUnitsE"]
    pub fn vex_brain_battery_voltage(this: *mut vex_brain_battery, units: vex_voltageUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Gets the battery current.\n @return Returns a double that represents the batteries current in the units specified by the parameter.\n @param units The type of current to be returned."]
    #[link_name = "\u{1}_ZN3vex5brain7battery7currentENS_12currentUnitsE"]
    pub fn vex_brain_battery_current(this: *mut vex_brain_battery, units: vex_currentUnits) -> f64;
}
impl vex_brain_battery {
    #[inline]
    pub unsafe fn capacity(&mut self, units: vex_percentUnits) -> u32 {
        vex_brain_battery_capacity(self, units)
    }
    #[inline]
    pub unsafe fn temperature(&mut self, units: vex_percentUnits) -> f64 {
        vex_brain_battery_temperature(self, units)
    }
    #[inline]
    pub unsafe fn temperature1(&mut self, units: vex_temperatureUnits) -> f64 {
        vex_brain_battery_temperature1(self, units)
    }
    #[inline]
    pub unsafe fn voltage(&mut self, units: vex_voltageUnits) -> f64 {
        vex_brain_battery_voltage(self, units)
    }
    #[inline]
    pub unsafe fn current(&mut self, units: vex_currentUnits) -> f64 {
        vex_brain_battery_current(self, units)
    }
}
#[doc = " @brief Use the SD Card class to load or save files on your SD card."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_brain_sdcard {
    pub _address: u8,
}
extern "C" {
    #[doc = " @brief Gets the state of the SD card\n @return Returns true if the SD card is inserted. Returns false if there is not an SD card inserted."]
    #[link_name = "\u{1}_ZN3vex5brain6sdcard10isInsertedEv"]
    pub fn vex_brain_sdcard_isInserted(this: *mut vex_brain_sdcard) -> bool;
}
extern "C" {
    #[doc = " @return Returns the number of bytes read from the file.\n @brief Loads a file from the SD card.\n @param name The name of the file.\n @param buffer Pointer to a buffer for file data.\n @param len The length of the buffer in bytes. Usually set to the max length of the buffer."]
    #[link_name = "\u{1}_ZN3vex5brain6sdcard8loadfileEPKcPhi"]
    pub fn vex_brain_sdcard_loadfile(
        this: *mut vex_brain_sdcard,
        name: *const ::core::ffi::c_char,
        buffer: *mut u8,
        len: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Saves a file to the SD card.\n @return Returns the number of bytes saved to the file.\n @param name The name of the file.\n @param buffer Pointer to a buffer with file data.\n @param len The length of the buffer in bytes. Usually set to the max length of the buffer."]
    #[link_name = "\u{1}_ZN3vex5brain6sdcard8savefileEPKcPhi"]
    pub fn vex_brain_sdcard_savefile(
        this: *mut vex_brain_sdcard,
        name: *const ::core::ffi::c_char,
        buffer: *mut u8,
        len: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief Appends data to an existing file.\n @return Returns the number of bytes saved to the file.\n @param name The name of the file.\n @param buffer Pointer to a buffer with file data.\n @param len The length of the buffer in bytes. Usually set to the max length of the buffer."]
    #[link_name = "\u{1}_ZN3vex5brain6sdcard10appendfileEPKcPhi"]
    pub fn vex_brain_sdcard_appendfile(
        this: *mut vex_brain_sdcard,
        name: *const ::core::ffi::c_char,
        buffer: *mut u8,
        len: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief get the size in bytes of the named file\n @return size of file in bytes\n @param name The name of the file."]
    #[link_name = "\u{1}_ZN3vex5brain6sdcard4sizeEPKc"]
    pub fn vex_brain_sdcard_size(
        this: *mut vex_brain_sdcard,
        name: *const ::core::ffi::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " @brief check if the named file exists\n @return true if the file exists\n @param name The name of the file."]
    #[link_name = "\u{1}_ZN3vex5brain6sdcard6existsEPKc"]
    pub fn vex_brain_sdcard_exists(
        this: *mut vex_brain_sdcard,
        name: *const ::core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5brain6sdcardC1Ev"]
    pub fn vex_brain_sdcard_sdcard(this: *mut vex_brain_sdcard);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5brain6sdcardD1Ev"]
    pub fn vex_brain_sdcard_sdcard_destructor(this: *mut vex_brain_sdcard);
}
impl vex_brain_sdcard {
    #[inline]
    pub unsafe fn isInserted(&mut self) -> bool {
        vex_brain_sdcard_isInserted(self)
    }
    #[inline]
    pub unsafe fn loadfile(
        &mut self,
        name: *const ::core::ffi::c_char,
        buffer: *mut u8,
        len: i32,
    ) -> i32 {
        vex_brain_sdcard_loadfile(self, name, buffer, len)
    }
    #[inline]
    pub unsafe fn savefile(
        &mut self,
        name: *const ::core::ffi::c_char,
        buffer: *mut u8,
        len: i32,
    ) -> i32 {
        vex_brain_sdcard_savefile(self, name, buffer, len)
    }
    #[inline]
    pub unsafe fn appendfile(
        &mut self,
        name: *const ::core::ffi::c_char,
        buffer: *mut u8,
        len: i32,
    ) -> i32 {
        vex_brain_sdcard_appendfile(self, name, buffer, len)
    }
    #[inline]
    pub unsafe fn size(&mut self, name: *const ::core::ffi::c_char) -> i32 {
        vex_brain_sdcard_size(self, name)
    }
    #[inline]
    pub unsafe fn exists(&mut self, name: *const ::core::ffi::c_char) -> bool {
        vex_brain_sdcard_exists(self, name)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_brain_sdcard_sdcard(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_brain_sdcard_sdcard_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5brain9_getIndexEv"]
    pub fn vex_brain__getIndex() -> i32;
}
extern "C" {
    #[doc = " @brief Gets the value of the timer in the units specified.\n @param units The unit of time that will be returned.\n @return Returns a double that represents the value of the timer."]
    #[link_name = "\u{1}_ZN3vex5brain5timerENS_9timeUnitsE"]
    pub fn vex_brain_timer(this: *mut vex_brain, units: vex_timeUnits) -> f64;
}
extern "C" {
    #[doc = " @brief Resets the timer to zero."]
    #[link_name = "\u{1}_ZN3vex5brain10resetTimerEv"]
    pub fn vex_brain_resetTimer(this: *mut vex_brain);
}
extern "C" {
    #[doc = " @brief Sets the timer to a value and time unit.\n @param value The value that the timer is set to.\n @param units The unit of time that will be returned."]
    #[link_name = "\u{1}_ZN3vex5brain8setTimerEdNS_9timeUnitsE"]
    pub fn vex_brain_setTimer(this: *mut vex_brain, value: f64, units: vex_timeUnits);
}
extern "C" {
    #[doc = " @brief Creates a new brain object."]
    #[link_name = "\u{1}_ZN3vex5brainC1Ev"]
    pub fn vex_brain_brain(this: *mut vex_brain);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex5brainD1Ev"]
    pub fn vex_brain_brain_destructor(this: *mut vex_brain);
}
impl vex_brain {
    #[inline]
    pub unsafe fn _getIndex() -> i32 {
        vex_brain__getIndex()
    }
    #[inline]
    pub unsafe fn timer(&mut self, units: vex_timeUnits) -> f64 {
        vex_brain_timer(self, units)
    }
    #[inline]
    pub unsafe fn resetTimer(&mut self) {
        vex_brain_resetTimer(self)
    }
    #[inline]
    pub unsafe fn setTimer(&mut self, value: f64, units: vex_timeUnits) {
        vex_brain_setTimer(self, value, units)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_brain_brain(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_brain_brain_destructor(self)
    }
}
#[doc = " @brief Use this class to set up your program for competitions."]
#[repr(C)]
#[derive(Debug)]
pub struct vex_competition {
    pub _index: i32,
    pub _globalInstance: bool,
    pub PRE_AUTONOMOUS: vex_mevent,
    pub AUTONOMOUS: vex_mevent,
    pub DRIVER_CONTROL: vex_mevent,
    pub DISABLED: vex_mevent,
}
pub const vex_competition_tEventType_EVENT_INITIALIZE: vex_competition_tEventType = 8;
pub const vex_competition_tEventType_EVENT_AUTONOMOUS: vex_competition_tEventType = 9;
pub const vex_competition_tEventType_EVENT_DRIVER_CTL: vex_competition_tEventType = 10;
pub const vex_competition_tEventType_EVENT_DISABLE: vex_competition_tEventType = 11;
pub type vex_competition_tEventType = ::core::ffi::c_int;
extern "C" {
    #[link_name = "\u{1}_ZN3vex11competition14_auton_pendingE"]
    pub static mut vex_competition__auton_pending: bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11competition15_driver_pendingE"]
    pub static mut vex_competition__driver_pending: bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11competition20_initialize_callbackE"]
    pub static mut vex_competition__initialize_callback:
        ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11competition20_autonomous_callbackE"]
    pub static mut vex_competition__autonomous_callback:
        ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11competition23_drivercontrol_callbackE"]
    pub static mut vex_competition__drivercontrol_callback:
        ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[doc = " @brief Sets whether or not your program will stop the competition tasks between modes."]
    #[link_name = "\u{1}_ZN3vex11competition22bStopTasksBetweenModesE"]
    pub static mut vex_competition_bStopTasksBetweenModes: bool;
}
extern "C" {
    #[doc = " @brief Sets whether or not your program will stop all tasks and events between modes."]
    #[link_name = "\u{1}_ZN3vex11competition25bStopAllTasksBetweenModesE"]
    pub static mut vex_competition_bStopAllTasksBetweenModes: bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11competition9_getIndexEv"]
    pub fn vex_competition__getIndex(this: *mut vex_competition) -> i32;
}
extern "C" {
    #[doc = " @brief Calls back a function when the autonomous period starts.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex11competition10autonomousEPFvvE"]
    pub fn vex_competition_autonomous(
        this: *mut vex_competition,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Calls back a function when the driver control period starts.\n @param callback A reference to a function."]
    #[link_name = "\u{1}_ZN3vex11competition13drivercontrolEPFvvE"]
    pub fn vex_competition_drivercontrol(
        this: *mut vex_competition,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Gets the status of your robot when under competition control.\n @return Returns a Boolean based on if the autonomous or driver control periods is active. If either one is active, the Boolean will return true."]
    #[link_name = "\u{1}_ZN3vex11competition9isEnabledEv"]
    pub fn vex_competition_isEnabled(this: *mut vex_competition) -> bool;
}
extern "C" {
    #[doc = " @brief Gets the status of the Driver Control period.\n @return Returns a Boolean based on if the Driver Control Period is active. If the Driver Control period is active, the Boolean will return true."]
    #[link_name = "\u{1}_ZN3vex11competition15isDriverControlEv"]
    pub fn vex_competition_isDriverControl(this: *mut vex_competition) -> bool;
}
extern "C" {
    #[doc = " @brief Gets the status of the Autonomous period.\n @return Returns a Boolean based on if the Autonomous Period is active. If the Autonomous Period is active, the Boolean will return true."]
    #[link_name = "\u{1}_ZN3vex11competition12isAutonomousEv"]
    pub fn vex_competition_isAutonomous(this: *mut vex_competition) -> bool;
}
extern "C" {
    #[doc = " @brief Gets the status of the Competition Control Switch being plugged into the robot.\n @return Returns a Boolean based on if the V5 is connected to the Competition Control Switch. If the Brain is connected, the Boolean will return true."]
    #[link_name = "\u{1}_ZN3vex11competition19isCompetitionSwitchEv"]
    pub fn vex_competition_isCompetitionSwitch(this: *mut vex_competition) -> bool;
}
extern "C" {
    #[doc = " @brief Gets the status of the Field Control System being plugged into the robot.\n @return Returns a Boolean based on if the V5 is connected to the Field Control System. If the Brain is connected, the Boolean will return true."]
    #[link_name = "\u{1}_ZN3vex11competition14isFieldControlEv"]
    pub fn vex_competition_isFieldControl(this: *mut vex_competition) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11competition10test_autonEv"]
    pub fn vex_competition_test_auton(this: *mut vex_competition);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11competition11test_driverEv"]
    pub fn vex_competition_test_driver(this: *mut vex_competition);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11competition12test_disableEv"]
    pub fn vex_competition_test_disable(this: *mut vex_competition);
}
extern "C" {
    #[doc = " @brief Creates a competition object that has access to competition methods."]
    #[link_name = "\u{1}_ZN3vex11competitionC1Ev"]
    pub fn vex_competition_competition(this: *mut vex_competition);
}
extern "C" {
    #[link_name = "\u{1}_ZN3vex11competitionD1Ev"]
    pub fn vex_competition_competition_destructor(this: *mut vex_competition);
}
impl vex_competition {
    #[inline]
    pub unsafe fn _getIndex(&mut self) -> i32 {
        vex_competition__getIndex(self)
    }
    #[inline]
    pub unsafe fn autonomous(&mut self, callback: ::core::option::Option<unsafe extern "C" fn()>) {
        vex_competition_autonomous(self, callback)
    }
    #[inline]
    pub unsafe fn drivercontrol(
        &mut self,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    ) {
        vex_competition_drivercontrol(self, callback)
    }
    #[inline]
    pub unsafe fn isEnabled(&mut self) -> bool {
        vex_competition_isEnabled(self)
    }
    #[inline]
    pub unsafe fn isDriverControl(&mut self) -> bool {
        vex_competition_isDriverControl(self)
    }
    #[inline]
    pub unsafe fn isAutonomous(&mut self) -> bool {
        vex_competition_isAutonomous(self)
    }
    #[inline]
    pub unsafe fn isCompetitionSwitch(&mut self) -> bool {
        vex_competition_isCompetitionSwitch(self)
    }
    #[inline]
    pub unsafe fn isFieldControl(&mut self) -> bool {
        vex_competition_isFieldControl(self)
    }
    #[inline]
    pub unsafe fn test_auton(&mut self) {
        vex_competition_test_auton(self)
    }
    #[inline]
    pub unsafe fn test_driver(&mut self) {
        vex_competition_test_driver(self)
    }
    #[inline]
    pub unsafe fn test_disable(&mut self) {
        vex_competition_test_disable(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        vex_competition_competition(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        vex_competition_competition_destructor(self)
    }
}
